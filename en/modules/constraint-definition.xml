<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../docbook-support/support/docbook-dtd/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../global.ent">
%BOOK_ENTITIES;
]>
<chapter id="constraintsdefinitionimplementation">
  <title>Constraint Definition</title>

  <para>Constraints are defined by the combination of a constraint annotation
  and a list of constraint validation implementations. The constraint
  annotation is applied on types, fields, methods, constructors, parameters or
  other constraint annotations in case of composition.</para>

  <para>Unless stated otherwise the default package name for the Bean
  Validation APIs is <classname>javax.validation</classname>.</para>

  <section id="constraintsdefinitionimplementation-constraintdefinition">
    <title>Constraint annotation</title>

    <para>A constraint on a JavaBean is expressed through one or more
    annotations. <phrase role="tck-not-testable">An annotation is considered a
    constraint definition if its retention policy contains
    <literal>RUNTIME</literal> and if the annotation itself is annotated with
    <literal>javax.validation.Constraint</literal></phrase>.</para>

    <programlisting>/**
 * Marks an annotation as being a Bean Validation constraint.
 * &lt;p/&gt;
 * A given constraint annotation must be annotated by a {@code @Constraint}
 * annotation which refers to its list of constraint validation implementations.
 * &lt;p/&gt;
 * Each constraint annotation must host the following attributes:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code String message() default [...];} which should default to an error
 *     message key made of the fully-qualified class name of the constraint followed by
 *     {@code .message}. For example {@code "{com.acme.constraints.NotSafe.message}"}&lt;/li&gt;
 *     &lt;li&gt;{@code Class&lt;?&gt;[] groups() default {};} for user to customize the targeted
 *     groups&lt;/li&gt;
 *     &lt;li&gt;{@code Class&lt;? extends Payload&gt;[] payload() default {};} for
 *     extensibility purposes&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * When building a constraint that is both generic and cross-parameter, the constraint
 * annotation must host the {@code validationAppliesTo()} property.
 * A constraint is generic if it targets the annotated element and is cross-parameter if
 * it targets the array of parameters of a method or constructor.
 * &lt;pre&gt;
 *     ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;
 * &lt;/pre&gt;
 * This property allows the constraint user to choose whether the constraint
 * targets the return type of the executable or its array of parameters.
 *
 * A constraint is both generic and cross-parameter if
 * &lt;ul&gt;
 *     &lt;li&gt;two kinds of {@code ConstraintValidator}s are attached to the
 *     constraint, one targeting {@link ValidationTarget.ANNOTATED_ELEMENT}
 *     and one targeting {@link ValidationTarget.PARAMETERS},&lt;/li&gt;
 *     &lt;li&gt;or if a {@code ConstraintValidator} targets both
 *     {@code ANNOTATED_ELEMENT} and
 *     {@code PARAMETERS}.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Such dual constraints are rare. See {@link SupportedValidationTarget} for more info.
 * &lt;p/&gt;
 * Here is an example of constraint definition:
 * &lt;pre&gt;
 * &amp;#64;Documented
 * &amp;#64;Constraint(validatedBy = OrderNumberValidator.class)
 * &amp;#64;Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
 * &amp;#64;Retention(RUNTIME)
 * public &amp;#64;interface OrderNumber {
 *     String message() default "{com.acme.constraint.OrderNumber.message}";
 *     Class&lt;?&gt;[] groups() default {};
 *     Class&lt;? extends Payload&gt;[] payload() default {};
 * }
 * &lt;/pre&gt;
 *
 * @author Emmanuel Bernard
 * @author Gavin King
 * @author Hardy Ferentschik
 */
@Documented
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface Constraint {

    /**
     * {@link ConstraintValidator} classes must reference distinct target types
     * for a given {@link ValidationTarget}
     * If two {@code ConstraintValidator}s refer to the same type,
     * an exception will occur.
     * &lt;p/&gt;
     * At most one {@code ConstraintValidator} targeting the array of parameters of
     * methods or constructors (aka cross-parameter) is accepted. If two or more
     * are present, an exception will occur.
     *
     * @return array of (@code ConstraintValidator} classes implementing the constraint
     */
    Class&lt;? extends ConstraintValidator&lt;?, ?&gt;&gt;[] validatedBy();
}</programlisting>

    <para revisionflag="added">A constraint is said to be generic if it has at
    least one constraint validator targeting the element annotated i.e.
    targeting the (returned) element annotated by the constraint (a bean, a
    field, a getter, a method/constructor return value or a method/constructor
    parameter). A constraint is said to be cross-parameter if it has one
    constraint validator targeting the array of parameters of a method or
    constructor (to validate the consistency of several method/constructor
    parameters). A Bean Validation constraint is most of the time either a
    generic constraint or a cross-parameter constraint. In rare situations, a
    constraint can be both.</para>

    <para role="tck-not-testable">Generic constraint annotations can target
    any of the following <classname>ElementType</classname>s:<itemizedlist>
        <listitem>
          <para><literal>FIELD</literal> for constrained attributes</para>
        </listitem>

        <listitem>
          <para><literal>METHOD</literal> for constrained getters<phrase
          revisionflag="added"> and constrained method return
          values</phrase></para>
        </listitem>

        <listitem revisionflag="added">
          <para><classname>CONSTRUCTOR</classname> for constrained constructor
          return values</para>
        </listitem>

        <listitem revisionflag="added">
          <para><classname>PARAMETER</classname> for constrained method and
          constructor parameters</para>
        </listitem>

        <listitem>
          <para><literal>TYPE</literal> for constrained beans</para>
        </listitem>

        <listitem>
          <para><literal>ANNOTATION_TYPE</literal> for constraints composing
          other constraints</para>
        </listitem>
      </itemizedlist></para>

    <para revisionflag="added" role="tck-not-testable">Cross-parameter
    constraint annotations can target any of the following
    <classname>ElementType</classname>s: <itemizedlist>
        <listitem>
          <para><literal>METHOD</literal></para>
        </listitem>

        <listitem>
          <para><literal>CONSTRUCTOR</literal></para>
        </listitem>

        <listitem>
          <para><literal>ANNOTATION_TYPE</literal> for cross-parameter
          constraints composing other cross-parameter constraints</para>
        </listitem>
      </itemizedlist></para>

    <para revisionflag="added" role="tck-testable">A constraint annotation
    that is both can target the union of the generic and cross-parameter
    constraint annotations targets.</para>

    <para>While other <classname>ElementType</classname>s are not forbidden,
    the provider does not have to recognize and process constraints placed on
    such types.</para>

    <para>Since a given constraint definition applies to one or more specific
    Java types, the JavaDoc for the constraint annotation should clearly state
    which types are supported. <phrase role="tck-testable">Applying a
    constraint annotation to an incompatible type will raise an
    <classname>UnexpectedTypeException</classname>.</phrase> Care should be
    taken on defining the list of <classname>ConstraintValidator</classname>s.
    The type resolution algorithm (see <xref
    linkend="typevalidatorresolution"/>) could lead to exceptions if the
    <classname>ConstraintValidator</classname> list leads to
    ambiguities.</para>

    <para revisionflag="added"><phrase role="tck-testable">At most one
    <classname>ConstraintValidator</classname> supporting cross-parameter
    validation must be present for a given constraint. A
    <classname>ConstraintDefinitionException</classname> is raised
    otherwise.</phrase> The JavaDoc should clearly state if the constraint is
    a generic and / or a cross-parameter constraint.</para>

    <para><phrase role="tck-testable">If a constraint definition is not valid,
    a <classname>ConstraintDefinitionException</classname> is raised either at
    validation time or when the metadata is requested.</phrase> Invalid
    constraint definitions causes are multiple but include missing or illegal
    <methodname>message</methodname> or <methodname>groups</methodname>
    elements (see <xref
    linkend="constraintsdefinitionimplementation-constraintdefinition-properties"/>).</para>

    <note revisionflag="added">
      <para>Bean Validation defines rules for applying constraint annotations
      in inheritance hierarchies, described in <xref
      linkend="constraintdeclarationvalidationprocess-inheritance"/> and <xref
      linkend="constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance"/>.
      It is therefore not recommended to specify the meta annotation
      <classname>java.lang.annotation.Inherited</classname> at constraint
      annotation types, as it is not relevant in the context of Bean
      Validation and would conflict with the proposed rules.</para>
    </note>

    <section id="constraintsdefinitionimplementation-constraintdefinition-properties">
      <title>Constraint definition properties</title>

      <para><phrase role="tck-testable">A constraint definition may have
      attributes that are specified at the time the constraint is applied to a
      JavaBean.</phrase> The properties are mapped as annotation elements. The
      annotation element names <literal>message</literal>,
      <literal>groups</literal>, <literal
      revisionflag="added">validationAppliesTo</literal> and
      <literal>payload</literal> are considered reserved names; <phrase
      role="tck-testable">annotation elements starting with
      <literal>valid</literal> are not allowed</phrase>; a constraint may use
      any other element name for its attributes.</para>

      <section id="constraintsdefinitionimplementation-constraintdefinition-parameters-message">
        <title>message</title>

        <para role="tck-testable">Every constraint annotation must define a
        <literal>message</literal> element of type
        <literal>String</literal>.</para>

        <programlisting>String message() default "{com.acme.constraint.MyConstraint.message}";</programlisting>

        <para>The <methodname>message</methodname> element value is used to
        create the error message. See <xref linkend="validationapi-message"/>
        for a detailed explanation. It is recommended to default
        <literal>message</literal> values to resource bundle keys to enable
        internationalization. It is also recommended to use the following
        convention: the resource bundle key should be the fully qualified
        class name of the constraint annotation concatenated to
        <literal>.message</literal> as shown in the previous program
        listing.</para>

        <para>Built-in Bean Validation constraints follow this
        convention.</para>
      </section>

      <section id="constraintsdefinitionimplementation-constraintdefinition-groups">
        <title>groups</title>

        <para><phrase role="tck-testable">Every constraint annotation must
        define a <literal>groups</literal> element that specifies the
        processing groups with which the constraint declaration is associated.
        </phrase><phrase revisionflag="added" role="tck-testable">The type of
        the <literal>groups</literal> parameter is
        <classname>Class&lt;?&gt;[]</classname>.</phrase></para>

        <programlisting>Class&lt;?&gt;[] groups() default {};</programlisting>

        <para role="tck-testable">The default value must be an empty
        array.</para>

        <para role="tck-testable">If no group is specified when declaring the
        constraint on an element, the <literal>Default</literal> group is
        considered declared.</para>

        <para>See <xref linkend="validationapi-validatorapi-groups"/> for more
        information.</para>

        <para>Groups are typically used to control the order in which
        constraints are evaluated, or to perform validation of the partial
        state of a JavaBean.</para>
      </section>

      <section id="constraintsdefinitionimplementation-constraintdefinition-payload">
        <title>payload</title>

        <para role="tck-testable tck-needs-update">Constraint annotations must
        define a <literal>payload</literal> element that specifies the payload
        with which the the constraint declaration is associated. The type of
        the <literal>payload</literal> parameter is
        <classname>Payload[]</classname>.</para>

        <programlisting>Class&lt;? extends Payload&gt;[] payload() default {};</programlisting>

        <para role="tck-testable">The default value must be an empty
        array.</para>

        <para role="tck-testable">Each attachable payload extends
        <classname>Payload</classname>.</para>

        <programlisting>/**
 * Payload type that can be attached to a given
 * constraint declaration.
 * &lt;p/&gt;
 * Payloads are typically used to carry on metadata information
 * consumed by a validation client.
 * &lt;/p&gt;
 * Use of payloads is not considered portable.
 *
 * @author Emmanuel Bernard
 * @author Gerhard Petracek
 */
public interface Payload {
}</programlisting>

        <para>Payloads are typically used by validation clients to associate
        some metadata information with a given constraint declaration.
        Payloads are typically non-portable. Describing payloads as interface
        extensions as opposed to a string-based approach allows an easier and
        more type-safe approach.</para>

        <para>One use case for payload shown in <xref
        linkend="example-payload"/> is to associate a severity to a
        constraint. This severity can be exploited by a presentation framework
        to adjust how a constraint failure is displayed.</para>

        <example id="example-payload">
          <title>Use of payload to associate severity to a constraint</title>

          <programlisting>package com.acme.severity;

public class Severity {
    public static class Info implements Payload {};
    public static class Error implements Payload {};
}

public class Address {
    @NotNull(message="would be nice if we had one", payload=Severity.Info.class)
    public String getZipCode() { [...] }

    @NotNull(message="the city is mandatory", payload=Severity.Error.class) 
    String getCity() { [...] }
}</programlisting>
        </example>

        <para>The <literal>payload</literal> information can be retrieved from
        error reports via the <classname>ConstraintDescriptor</classname>
        either accessed through the <classname>ConstraintViolation</classname>
        objects (see <xref linkend="validationapi-constraintviolation"/>) or
        through the metadata API (see <xref
        linkend="constraintmetadata-constraintdescriptor"/>).</para>
      </section>

      <section id="constraintsdefinitionimplementation-constraintdefinition-validationappliesto"
               revisionflag="added">
        <title>validationAppliesTo</title>

        <para><literal>validationAppliesTo</literal> is used at constraint
        declaration time to clarify what the constraint targets (i.e. the
        annotated element, the method return value or the method
        parameters).</para>

        <para role="tck-testable">The element
        <literal>validationAppliesTo</literal> must only be present for
        constraints that are both generic and cross-parameter, it is mandatory
        in this situation. A
        <classname>ConstraintDefinitionException</classname> is raised if
        these rules are violated.</para>

        <para revisionflag="added" role="tck-testable">The type of the
        <literal>validationAppliesTo</literal> parameter is
        <classname>ConstraintTarget</classname>. The default value must be
        <classname>ConstraintTarget.IMPLICIT</classname>.</para>

        <example>
          <title>validationAppliesTo and ConstraintTarget</title>

          <programlisting>ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;</programlisting>

          <programlisting>/**
 * Defines the constraint target.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public enum ConstraintTarget {

    /**
     * Discover the type when no ambiguity is present
     * &lt;ul&gt;
     *     &lt;li&gt;if neither on a method nor a constructor, it implies the annotated element
     *     (type, field etc),&lt;/li&gt;
     *     &lt;li&gt;if on a method or constructor with no parameter, it implies
     *     {@code RETURN_VALUE},&lt;/li&gt;
     *     &lt;li&gt;if on a method with no return value ({@code void}), it implies
     *     {@code PARAMETERS}.&lt;/li&gt;
     * &lt;/ul&gt;
     * Otherwise, {@code IMPLICIT} is not accepted and either {@code RETURN_VALUE} or
     * {@code PARAMETERS} is required. This is the case for constructors with parameters
     * and methods with parameters and return value.
     */
    IMPLICIT,

    /**
     * Constraint applies to the return value of a method or a constructor.
     */
    RETURN_VALUE,

    /**
     * Constraint applies to the parameters of a method or a constructor
     */
    PARAMETERS
}</programlisting>
        </example>

        <para><phrase role="tck-testable">If a
        <classname>ConstraintTarget</classname> is used in an illegal
        situation, a <classname>ConstraintDeclarationException</classname> is
        raised either at validation time or when the metadata is
        requested.</phrase> Examples of illegal situations are:</para>

        <itemizedlist>
          <listitem>
            <para role="tck-testable">using <literal>IMPLICIT</literal> in a
            situation that cannot be inferred (see the JavaDoc for the
            detailed rules),</para>
          </listitem>

          <listitem>
            <para role="tck-testable">using <literal>PARAMETERS</literal> on a
            constructor or method that has no parameter,</para>
          </listitem>

          <listitem>
            <para role="tck-testable">using <literal>RETURN_VALUE</literal> on
            a method with no return value,</para>
          </listitem>

          <listitem>
            <para role="tck-testable">using <literal>PARAMETERS</literal> or
            <literal>RETURN_VALUE</literal> on a type - class or interface -
            or on a field.</para>
          </listitem>
        </itemizedlist>

        <para>Constraint users are encouraged to explicitly set the
        <classname>ConstraintTarget</classname> target when using a constraint
        supporting both on a method or constructor as it improves
        readability.</para>
      </section>

      <section>
        <title>Constraint specific parameter</title>

        <para>The constraint annotation definitions may define additional
        elements to parameterize the constraint. For example, a constraint
        that validates the length of a string can use an annotation element
        named <literal>length</literal> to specify the maximum length at the
        time the constraint is declared.</para>
      </section>
    </section>

    <section>
      <title>Examples</title>

      <example id="example-definition-notnull">
        <title>Simple constraint definition</title>

        <programlisting>//assuming OrderNumberValidator is a generic constraint validator

package com.acme.constraint;

/**
 * Mark a String as representing a well formed order number
 */
@Documented
@Constraint(validatedBy = OrderNumberValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface OrderNumber {
    String message() default "{com.acme.constraint.OrderNumber.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</programlisting>
      </example>

      <para><xref linkend="example-definition-notnull"/> marks a
      <classname>String</classname> as a well-formed order number. The
      constraint validator is implemented by
      <classname>OrderNumberValidator</classname>.</para>

      <example id="example-definition-crossparameter" revisionflag="added">
        <title>Simple cross-parameter constraint definition</title>

        <programlisting>//assuming DateParametersConsistentValidator is a cross-parameter
//constraint validator

package com.acme.constraint;

/**
 * Cross-parameter constraint ensuring that two date parameters
 * of a method are in the correct order.
 */
@Documented
@Constraint(validatedBy = DateParametersConsistentValidator.class)
@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface DateParametersConsistent {
    String message() default "{com.acme.constraint.DateParametersConsistent.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</programlisting>
      </example>

      <para revisionflag="added"><xref
      linkend="example-definition-crossparameter"/> shows a cross-parameter
      constraint which ensures that two date parameters of a method are in the
      correct order. The constraint validator is implemented by
      <classname>DateParametersConsistentValidator</classname>.</para>

      <example id="example-definition-genericandcrossparameter"
               revisionflag="added">
        <title>Constraint that is both generic and cross parameter</title>

        <programlisting>//assuming ELAssertValidator is both a generic and cross-parameter
//constraint validator

package com.acme.constraint;

/**
 * EL expression to be validated.
 * This constraint accepts any type and can validate both the
 * annotated type or apply restrictions across parameters.
 */
@Documented
@Constraint(validatedBy=ELAssertValidator.class)
@Target({ METHOD, FIELD, TYPE, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface ELAssert {
    String message() default "{com.acme.constraint.DateParametersConsistent.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
    ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;

    String expression();
}</programlisting>

        <programlisting>@ELAssert(
    message="Please check that your passwords match and try again.",
    expression="param[1]==param[2]", 
    validationAppliesTo=ConstraintType.PARAMETERS
)
public User createUser(String email, String password, String repeatPassword) { [...] }</programlisting>
      </example>

      <para revisionflag="added"><xref
      linkend="example-definition-genericandcrossparameter"/> shows a
      constraint that can be applied both on the annotated element and across
      parameters of a method or a constructor. Note in this case the presence
      of <methodname>validationAppliesTo</methodname>.</para>

      <example id="example-definition-length">
        <title>Constraint definition with default parameter</title>

        <programlisting>package com.acme.constraint;

/**
 * A frequency in Hz as audible to human ear.
 * Adjustable to the age of the person.
 * Accept Numbers.
 */
@Documented
@Constraint(validatedBy = AudibleValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Audible {
    Age age() default Age.YOUNG;
    String message() default "{com.acme.constraint.Audible.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    public enum Age {
        YOUNG,
        WONDERING
        OLD
    }
}</programlisting>
      </example>

      <para><xref linkend="example-definition-length"/> ensures that a given
      frequency is within the scope of human ears. The constraint definition
      includes an optional parameter that may be specified when the constraint
      is applied.</para>

      <example id="example-definition-mandatory">
        <title>Constraint definition with mandatory parameter</title>

        <programlisting>package com.acme.constraint;

/**
 * Defines the list of values accepted
 * Accepts int or Integer objects
 */
@Documented
@Constraint(validatedBy = DiscreteListOfIntegerValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Acceptable {
    int[] value();
    String message() default "{com.acme.constraint.Acceptable.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</programlisting>
      </example>

      <para><xref linkend="example-definition-mandatory"/> defines a list of
      acceptable values expressed as an array: the
      <methodname>value</methodname> property must be specified when the
      constraint is applied.</para>
    </section>
  </section>

  <section id="constraintsdefinitionimplementation-multipleconstraints">
    <title>Applying multiple constraints of the same type</title>

    <para>It is often useful to declare the same constraint more than once to
    the same target, with different properties. A common example is the
    <literal>@Pattern</literal> constraint, which validates that its target
    matches a specified regular expression. Other constraints have this
    requirement as well. The same constraint type can belong to different
    groups and have specific error messages depending on the targeted
    group.</para>

    <para>To support this requirement, <phrase role="tck-testable">the bean
    validation provider treats regular annotations (annotations not annotated
    by <classname>@Constraint</classname>) whose <literal>value</literal>
    element has a return type of an array of constraint annotations in a
    special way. Each element in the <literal>value</literal> array are
    processed by the Bean Validation implementation as regular constraint
    annotations.</phrase> This means that each constraint specified in the
    <literal>value</literal> element is applied to the target. The annotation
    must have retention <literal>RUNTIME</literal> and can be applied on a
    type, field, property, executable parameter, executable return value,
    executable cross-parameter or another annotation. It is recommended to use
    the same set of targets as the initial constraint.</para>

    <para>Note to constraint designers: each constraint annotation should be
    coupled with its corresponding multi-valued annotation. The specification
    recommends, though does not mandate, the definition of an inner annotation
    named <classname>List</classname>.</para>

    <example>
      <title>Multi-valued constraint definition</title>

      <programlisting>/**
 * Validate a zipcode for a given country 
 * The only supported type is String
 */
@Documented
@Constraint(validatedBy = ZipCodeValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface ZipCode {

    String countryCode();

    String message() default "{com.acme.constraint.ZipCode.message}";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Defines several @ZipCode annotations on the same element
     * @see (@link ZipCode}
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        ZipCode[] value();
    }    
}</programlisting>
    </example>

    <example>
      <title>Multi-valued constraint declaration</title>

      <programlisting>public class Address {
    @ZipCode.List( {
            @ZipCode(countryCode="fr", groups=Default.class
                     message = "zip code is not valid"),
            @ZipCode(countryCode="fr", groups=SuperUser.class
                     message = "zip code invalid. Requires overriding before saving.")
            } )
    private String zipcode;
}</programlisting>
    </example>

    <para>In this example, both constraints apply to the
    <methodname>zipcode</methodname> field but with different groups and with
    different error messages.</para>

    <para>Using two different multi-constraint annotations for the same
    underlying constraint type on the same target (i.e. class or property) is
    not considered portable and is discouraged.</para>
  </section>

  <section id="constraintsdefinitionimplementation-constraintcomposition">
    <title>Constraint composition</title>

    <para>This specification allows you to compose constraints to create
    higher level constraints.</para>

    <para>Constraint composition is useful in several ways:</para>

    <itemizedlist>
      <listitem>
        <para>Avoid duplication and facilitate reuse of more primitive
        constraints.</para>
      </listitem>

      <listitem>
        <para>Expose primitive constraints as part of a composed constraint in
        the metadata API and enhance tool awareness.</para>
      </listitem>
    </itemizedlist>

    <para>Composition is done by annotating a constraint annotation with the
    composing constraint annotations.</para>

    <example>
      <title>Composition is done by annotating the composed constraint</title>

      <programlisting>@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>
    </example>

    <para>Annotating an element with <classname>@FrenchZipcode</classname>
    (the composed annotation) is equivalent to annotating it with
    <classname>@Pattern(regexp="[0-9]*")</classname>, <classname>@Size(min=5,
    max=5)</classname> (the composing annotations) and
    <classname>@FrenchZipcode</classname>. <phrase
    role="tck-testable tck-needs-update">More formally, each constraint
    annotation hosted on a constraint annotation is applied to the target
    element and this is done recursively.</phrase> <phrase
    role="tck-testable">Note that the main annotation and its constraint
    validation implementation is also applied.</phrase> <phrase
    role="tck-testable">By default, each failing constraint generates an error
    report.</phrase> <phrase role="tck-testable">Groups from the main
    constraint annotation are inherited by the composing annotations.</phrase>
    <phrase role="tck-testable">Any <methodname>groups</methodname> definition
    on a composing annotation is ignored. </phrase><phrase
    role="tck-testable">Payload from the main constraint annotation is
    inherited by the composing annotations.</phrase> <phrase
    role="tck-testable">Any <methodname>payload</methodname> definition on a
    composing annotation is ignored. </phrase><phrase revisionflag="added"
    role="tck-testable">The constraint target from the main constraint
    annotation is inherited by the composing annotations.</phrase><phrase
    revisionflag="added" role="tck-testable"> Any
    <methodname>validationAppliesTo</methodname> definition on a composing
    annotation is ignored.</phrase></para>

    <para><phrase role="tck-testable">The type upon which composed constraint
    is placed must be compatible with all constraints (composing and
    composed).</phrase> A constraint designer should ensure that such a type
    exists and lists in the JavaDoc all the compatible types.</para>

    <para revisionflag="added"><phrase role="tck-testable">All composed and
    composing constraints must have a constraint type in common.</phrase> In
    particular, it is not legal to mix a pure generic constraint and a pure
    cross-parameter constraint.</para>

    <para>It is possible to ensure that composing annotations do not raise
    individual error reports. In this scenario, if one or more composing
    annotations are invalid, the main constraint is automatically considered
    invalid and the corresponding error report is generated. To mark a
    constraint as raising a single constraint error report if either the
    composed or one of the composing constraints fail, use the
    <classname>@ReportAsSingleViolation</classname> annotation.</para>

    <example>
      <title>If any of the composing constraints fail, the error report
      corresponding to @FrenchZipcode is raised and none other.</title>

      <programlisting>@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@ReportAsSingleViolation
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>
    </example>

    <para>The definition of <classname>@ReportAsSingleViolation</classname> is
    as follows.</para>

    <programlisting revisionflag="changed">/**
 * A constraint annotation hosting this annotation will return the
 * composed annotation error report if any of the composing annotations fail.
 * The error reports of each individual composing constraint are ignored.
 * &lt;p/&gt;
 * Note: Evaluation of composed constraints stops on the first validation
 * error in case the composing constraint is annotated with
 * {@code @ReportAsSingleViolation}.
 *
 * @author Emmanuel Bernard
 */
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface ReportAsSingleViolation {
}</programlisting>

    <para revisionflag="changed" role="tck-testable">More specifically, if a
    composed constraint is marked as
    <classname>@ReportAsSingleViolation</classname>, the evaluation of the
    composing constraints stops at the first failing constraint and the error
    report corresponding to the composed constraint is generated and
    returned.</para>

    <para role="tck-testable tck-needs-update">Composing annotations can
    define the value of <literal>message</literal> and custom attributes
    (excluding <methodname>groups</methodname>,
    <methodname>payload</methodname> <phrase revisionflag="added">and
    <methodname>validationAppliesTo</methodname></phrase>) but these are fixed
    in the composed constraint definition.</para>

    <example>
      <title>Composing annotations can use attributes. They are fixed for a
      given main annotation. All @FrenchZipcode constraints have a @Size
      restricted to 5.</title>

      <programlisting>@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>
    </example>

    <para role="tck-testable">It is possible to override attributes and
    messages defined on a composing annotation. An attribute from the main
    annotation is used to override one or more attributes of the composing
    annotations. Such an attribute is annotated with the
    <classname>@OverridesAttribute</classname> annotation or its multivalued
    equivalent <classname>@OverridesAttribute.List</classname>.</para>

    <example id="example-composing-overridden">
      <title>Attributes from composing annotations can be overridden by
      attributes from the composed annotation.</title>

      <programlisting>@Pattern(regexp="[0-9]*")
@Size
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @OverridesAttribute.List( {
        @OverridesAttribute(constraint=Size.class, name="min"),
        @OverridesAttribute(constraint=Size.class, name="max") } )
    int size() default 5;

    @OverridesAttribute(constraint=Size.class, name="message")
    String sizeMessage() default "{com.acme.constraint.FrenchZipcode.zipcode.size}";

    @OverridesAttribute(constraint=Pattern.class, name="message")
    String numberMessage() default "{com.acme.constraint.FrenchZipcode.number.size}";

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>
    </example>

    <para>The value of the composed constraint attribute annotated with
    <classname>@OverridesAttribute</classname>
    (<methodname>@FrenchZipcode.sizeMessage</methodname>) is applied to the
    composing constraint attribute named after
    <methodname>OverridesAttribute.name</methodname> and hosted on the
    composing constraint of type
    <methodname>OverridesAttribute.constraint</methodname>
    (<methodname>@Size.message</methodname>). Similarly,
    <classname>@FrenchZipcode.numberMessage</classname> value is mapped to
    <classname>@Pattern.message</classname>.</para>

    <para>If left undefined, the default value for
    <methodname>@OverridesAttribute.name</methodname> is the name of the
    composed constraint attribute hosting the
    <classname>@OverridesAttribute</classname> annotation.</para>

    <para role="tck-testable">The types of the overridden and overriding
    attributes must be identical.</para>

    <note>
      <para><phrase role="tck-testable">A composing constraint can itself be a
      composed constraint. In this case, attribute values are overridden
      recursively according to the described rules.</phrase> Note however,
      that a forwarding rule (as defined by
      <classname>@OverridesAttribute</classname>) is only applied to the
      direct composing constraints.</para>
    </note>

    <para>Using <xref linkend="example-composing-overridden"/>,</para>

    <programlisting>@FrenchZipcode(size=9, sizeMessage="Zipcode should be of size {max}")</programlisting>

    <para>is equivalent to</para>

    <programlisting>@FrenchZipcode</programlisting>

    <para>if <classname>@FrenchZipcode</classname> is defined as</para>

    <programlisting>@Pattern(regexp="[0-9]*")
@Size(min=9, max=9, message="Zipcode should be of size {max}")
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>

    <para><phrase role="tck-testable">If a constraint is used more than once
    as a composing constraint, the multi value constraints model as described
    in <xref
    linkend="constraintsdefinitionimplementation-multipleconstraints"/> is
    used.</phrase> <phrase role="tck-testable">To select a specific composing
    constraint, <methodname>OverridesAttribute.constraintIndex</methodname> is
    used. It represents the constraint index in the
    <methodname>value</methodname> array.</phrase> <phrase
    role="tck-testable">If <literal>index</literal> is undefined, the single
    constraint declaration is targeted.</phrase></para>

    <example>
      <title>Use of constraintIndex in @OverridesAttribute</title>

      <programlisting>@Pattern.List( {
    @Pattern(regexp="[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}"), //email
    @Pattern(regexp=".*?emmanuel.*?") //emmanuel
} )
@Constraint(validatedBy={})
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface EmmanuelsEmail {
    String message() default "Not emmanuel's email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=0)
    String emailMessage() default "Not an email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=1)
    String emmanuelMessage() default "Not Emmanuel";

    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        EmmanuelsEmail[] value();
    }
}</programlisting>
    </example>

    <para><classname>@OverridesAttribute</classname> definition is as
    follows:</para>

    <programlisting>/**
 * Marks an attribute as overriding the attribute of a composing constraint.
 * Both attributes must share the same type.
 *
 * @author Emmanuel Bernard
 */
@Retention(RUNTIME)
@Target({ METHOD })
public @interface OverridesAttribute {

    /**
     * @return constraint type the attribute is overriding
     */
    Class&lt;? extends Annotation&gt; constraint();

    /**
     * Name of the Constraint attribute overridden.
     * Defaults to the name of the attribute hosting {@code @OverridesAttribute}.
     *
     * @return name of constraint attribute overridden
     */
    String name();

    /**
     * The index of the targeted constraint declaration when using
     * multiple constraints of the same type.
     * &lt;p/&gt;
     * The index represents the index of the constraint in the
     * {@code value()} array.
     * &lt;p/&gt;
     * By default, no index is defined and the single constraint declaration
     * is targeted.
     *
     * @return constraint declaration index if multivalued annotation is used
     */
    int constraintIndex() default -1;

    /**
     * Defines several {@link OverridesAttribute} annotations on the same element
     *
     * @see javax.validation.OverridesAttribute
     */
    @Documented
    @Target({ METHOD })
    @Retention(RUNTIME)
    public @interface List {

        OverridesAttribute[] value();
    }
}</programlisting>

    <para>The following elements uniquely identify an overridden constraint
    attribute:</para>

    <itemizedlist>
      <listitem>
        <para><methodname>OverridesAttribute.constraint</methodname></para>
      </listitem>

      <listitem>
        <para><methodname>OverridesAttribute.name</methodname></para>
      </listitem>

      <listitem>
        <para><methodname>OverridesAttribute.constraintIndex</methodname></para>
      </listitem>
    </itemizedlist>

    <para role="tck-testable tck-needs-update">If the composition is invalid,
    e.g. <itemizedlist>
        <listitem>
          <para>infinitely recursive composition</para>
        </listitem>

        <listitem>
          <para>wrong attribute overriding</para>
        </listitem>

        <listitem>
          <para>a single attribute mapped to more than one source
          attribute</para>
        </listitem>

        <listitem>
          <para revisionflag="added">a composing and composed constraint
          marked as different constraint types (i.e., generic and
          cross-parameter)</para>
        </listitem>

        <listitem>
          <para>etc.</para>
        </listitem>
      </itemizedlist>a <classname>ConstraintDefinitionException</classname> is
    raised either at validation time or when the metadata is requested.</para>

    <para>Constraint designers are encouraged to make use of composition
    (recursively or not) based on the built-in constraints defined by the
    specification. The composing constraints are exposed through the Bean
    Validation metadata API (<xref
    linkend="constraintmetadata-constraintdescriptor"/>). This metadata is
    particularly useful for third-party metadata consumers like persistence
    frameworks generating database schemas (such as Java Persistence) or
    presentation frameworks.</para>
  </section>

  <section id="constraintsdefinitionimplementation-validationimplementation">
    <title>Constraint validation implementation</title>

    <para><phrase role="tck-testable">A constraint validation implementation
    performs the validation of a given constraint annotation for a given
    type.</phrase> <phrase role="tck-testable tck-needs-update">The
    implementation classes are specified by the <literal>validatedBy</literal>
    element of the <classname>@Constraint</classname> annotation that
    decorates the constraint definition.</phrase> <phrase
    role="tck-not-testable">The constraint validation implementation
    implements the <classname>ConstraintValidator</classname>
    interface.</phrase></para>

    <programlisting>/**
 * Defines the logic to validate a given constraint {@code A}
 * for a given object type {@code T}.
 * &lt;p/&gt;
 * Implementations must comply to the following restriction:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code T} must resolve to a non parameterized type&lt;/li&gt;
 *     &lt;li&gt;or generic parameters of {@code T} must be unbounded
 *     wildcard types&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * The annotation {@link SupportedValidationTarget} can be put on a
 * {@code ConstraintValidator} implementation to mark it as supporting
 * cross-parameter constraints. Check out {@link SupportedValidationTarget}
 * and {@link Constraint} for more information.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidator&lt;A extends Annotation, T&gt; {

    /**
     * Initializes the validator in preparation for
     * {@link #isValid(Object, ConstraintValidatorContext)} calls.
     * The constraint annotation for a given constraint declaration
     * is passed.
     * &lt;p/&gt;
     * This method is guaranteed to be called before any use of this instance for
     * validation.
     *
     * @param constraintAnnotation annotation instance for a given constraint declaration
     */
    void initialize(A constraintAnnotation);

    /**
     * Implements the validation logic.
     * The state of {@code value} must not be altered.
     * &lt;p/&gt;
     * This method can be accessed concurrently, thread-safety must be ensured
     * by the implementation.
     *
     * @param value object to validate
     * @param context context in which the constraint is evaluated
     *
     * @return {@code false} if {@code value} does not pass the constraint
     */
    boolean isValid(T value, ConstraintValidatorContext context);
}</programlisting>

    <para role="tck-not-testable">Some restrictions apply on the generic type
    <classname>T</classname> (used in the <methodname>isValid()</methodname>
    method). <classname>T</classname> must <itemizedlist>
        <listitem>
          <para>resolve to a non parameterized type (i.e. because the type is
          not using generics or because the raw type is used instead of the
          generic version)</para>
        </listitem>

        <listitem>
          <para>or generic parameters of <classname>T</classname> must be
          unbounded wildcard types (i.e. <literal>&lt;?&gt;</literal>).</para>
        </listitem>
      </itemizedlist></para>

    <note>
      <para>This restriction is not a theoretical limitation and a future
      version of the specification might allow it.</para>
    </note>

    <para revisionflag="added" role="tck-testable">By default, a
    <classname>ConstraintValidator</classname> targets the (returned) element
    annotated by the constraint. You can make a
    <classname>ConstraintValidator</classname> target the array of parameters
    of a method or constructor (aka cross-parameter) by annotating the
    validator implementation with
    <classname>@SupportedValidationTarget</classname>.</para>

    <example revisionflag="added">
      <title>@SupportedValidationTarget annotation and ValidationTarget
      enum</title>

      <programlisting>package javax.validation.constraintvalidation;

/**
 * Defines the target(s) a {@link ConstraintValidator} can validate.
 * &lt;p/&gt;
 * A {@code ConstraintValidator} can target the (returned) element
 * annotated by the constraint, the array of parameters of a method
 * or constructor (aka cross-parameter) or both.
 * &lt;p/&gt;
 * If {@code @SupportedValidationTarget} is not present, the
 * {@code ConstraintValidator} targets the (returned) element annotated
 * by the constraint.
 * &lt;p/&gt;
 * A {@code ConstraintValidator} targeting cross-parameter must accept
 * {@code Object[]} (or {@code Object}) as the type of object it validates.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
@Documented
@Target({ TYPE })
@Retention(RUNTIME)
public @interface SupportedValidationTarget {

    ValidationTarget[] value();
}</programlisting>

      <programlisting>package javax.validation.constraintvalidation;

/**
 * List of possible targets for a {@link ConstraintValidator}.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public enum ValidationTarget {

    /**
     * (Returned) element annotated by the constraint.
     */
    ANNOTATED_ELEMENT,

    /**
     * Array of parameters of the annotated method or constructor (aka cross-parameter).
     */
    PARAMETERS
}</programlisting>
    </example>

    <para revisionflag="added" role="tck-testable">A
    <classname>ConstraintValidator</classname> implementation can target both
    annotated elements and array of parameters.</para>

    <para revisionflag="added" role="tck-testable tck-needs-update">If a
    <classname>ConstraintValidator</classname> targets array of parameters
    (cross-parameter), <classname>T</classname> must resolve to
    <classname>Object[]</classname> (or <classname>Object</classname>) in
    order to have the array of parameter values passed to the
    <methodname>isValid()</methodname> method.</para>

    <example revisionflag="added">
      <title>Example of cross parameter ConstraintValidator</title>

      <programlisting>@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class ScriptAssertValidator implements ConstraintValidator&lt;ScriptAssert,Object[]&gt; {
    @Override
    public void initialize(ScriptAssert constraintAnnotation) {
        [...]
    }

    @Override
    public boolean isValid(Object[] value, ConstraintValidatorContext context) {
        [...]
    }
}</programlisting>
    </example>

    <para><xref
    linkend="example-constraintsdefinitionimplementation-validationimplementation-validdef"/>
    shows some examples of valid definitions.</para>

    <example id="example-constraintsdefinitionimplementation-validationimplementation-validdef"
             revisionflag="changed">
      <title>Valid ConstraintValidator definitions</title>

      <programlisting>//String is not making use of generics
public class SizeValidatorForString implements ConstraintValidator&lt;Size, String&gt; {
    [...]
}

//Collection uses generics but the raw type is used
public class SizeValidatorForCollection implements ConstraintValidator&lt;Size, Collection&gt; {
    [...]
}

//Collection uses generics and unbounded windcard type
public class SizeValidatorForCollection implements ConstraintValidator&lt;Size, Collection&lt;?&gt;&gt; {
    [...]
}

//Validator for cross-parameter constraint
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class DateParametersConsistentValidator 
    implements ConstraintValidator&lt;DateParametersConsistent, Object[]&gt; {
    [...]
}

//Validator for both annotated elements and executable parameters
@SupportedValidationTarget({ValidationTarget.ANNOTATED_ELEMENT, ValidationTarget.PARAMETERS})
public class ELScriptValidator implements ConstraintValidator&lt;ELScript, Object&gt; {
    [...]
}</programlisting>
    </example>

    <para>And some invalid definitions in <xref
    linkend="example-constraintsdefinitionimplementation-validationimplementation-invaliddef"/>.</para>

    <example id="example-constraintsdefinitionimplementation-validationimplementation-invaliddef"
             revisionflag="changed">
      <title>Invalid ConstraintValidator definitions</title>

      <programlisting>//parameterized type
public class SizeValidatorForString implements&lt;Size, Collection&lt;String&gt;&gt; {
    [...]
}

//parameterized type using bounded wildcard
public class SizeValidatorForCollection implements&lt;Size, Collection&lt;? extends Address&gt;&gt; {
    [...]
}

//cross-parameter validator accepting the wrong type
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class NumberPositiveValidator implements ConstraintValidator&lt;NumberPositive, Number&gt; {
    [...]
}</programlisting>
    </example>

    <para revisionflag="changed">The life cycle of a constraint validation
    implementation instance is undefined. Bean Validation providers are
    allowed to cache <classname>ConstraintValidator</classname> instances
    retrieved from the
    <classname>ConstraintValidatorFactory</classname>.</para>

    <!--EBE should we make explicit that instances cannot be shared if the annotations attributes are not the same?-->

    <para role="tck-testable">The <methodname>initialize()</methodname> method
    is called by the Bean validation provider prior to any use of the
    constraint implementation.</para>

    <para><phrase role="tck-testable">The <methodname>isValid()</methodname>
    method is evaluated by the Bean Validation provider each time a given
    value is validated.</phrase> <phrase role="tck-not-testable">It returns
    <literal>false</literal> if the value is not valid,
    <literal>true</literal> otherwise.</phrase> <phrase
    role="tck-not-testable"><literal>isValid()</literal> implementations must
    be thread-safe.</phrase></para>

    <para><phrase role="tck-testable">If the property is of an unanticipated
    type, an <literal>UnexpectedTypeException</literal> is raised.</phrase>
    <classname>ConstraintValidator</classname> implementations raise this
    exception themselves if they receive an unsupported type. However,
    constraint designers are encouraged to make use of specialized
    <classname>ConstraintValidator</classname> implementations and delegate
    the type resolution to the Bean Validation provider (see the type matching
    algorithm described in <xref linkend="typevalidatorresolution"/>).</para>

    <para role="tck-testable">If an exception occurs either in the
    <methodname>initialize()</methodname> or
    <methodname>isValid()</methodname> method, the runtime exception is
    wrapped into a <classname>ValidationException</classname> by the Bean
    Validation engine.</para>

    <para role="tck-not-testable">The constraint validation implementation is
    not allowed to change the state of the value passed to
    <methodname>isValid()</methodname>.</para>

    <note>
      <para>While not mandatory, it is considered a good practice to split the
      core constraint validation from the not null constraint validation (for
      example, an <classname>@Email</classname> constraint will return
      <literal>true</literal> on a null object, i.e. will not take care of the
      <classname>@NotNull</classname> validation).</para>

      <para><code>null</code> can have multiple meanings but is commonly used
      to express that a value does not make sense, is not available or is
      simply unknown. Those constraints on the value are orthogonal in most
      cases to other constraints. For example a String, if present, must be an
      email but can be null. Separating both concerns is a good
      practice.</para>
    </note>

    <para>The <classname>ConstraintValidatorContext</classname> object passed
    to the <methodname>isValid()</methodname> method carries information and
    operations available in the context the constraint is validated to.</para>

    <programlisting revisionflag="changed">/**
 * Provides contextual data and operation when applying a given constraint validator.
 *
 * At least one {@link ConstraintViolation} must be defined (either the default one,
 * of if the default {@code ConstraintViolation} is disabled, a custom one).
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintValidatorContext {

    /**
     * Disables the default {@link ConstraintViolation} object generation (which
     * is using the message template declared on the constraint).
     * &lt;p/&gt;
     * Useful to set a different violation message or generate a {@code ConstraintViolation}
     * based on a different property.
     */
    void disableDefaultConstraintViolation();

    /**
     * @return the current un-interpolated default message
     */
    String getDefaultConstraintMessageTemplate();

    /**
     * Returns a constraint violation builder building a violation report
     * allowing to optionally associate it to a sub path.
     * The violation message will be interpolated.
     * &lt;p/&gt;
     * To create the {@link ConstraintViolation}, one must call either one of
     * the {@code addConstraintViolation()} methods available in one of the
     * interfaces of the fluent API.
     * If another method is called after {@code addConstraintViolation()} on
     * {@code ConstraintViolationBuilder} or any of its associated nested interfaces
     * an {@code IllegalStateException} is raised.
     * &lt;p/&gt;
     * If {@link ConstraintValidator#isValid(Object, ConstraintValidatorContext)} returns
     * {@code false}, a {@code ConstraintViolation} object will be built per constraint
     * violation report including the default one (unless
     * {@link #disableDefaultConstraintViolation()} has been called).
     * &lt;p/&gt;
     * {@code ConstraintViolation} objects generated from such a call
     * contain the same contextual information (root bean, path and so on) unless
     * the path has been overridden.
     * &lt;p/&gt;
     * To create a different {@code ConstraintViolation}, a new constraint violation builder
     * has to be retrieved from {@code ConstraintValidatorContext}
     *
     * Here are a few usage examples:
     * &lt;pre&gt;
     * //assuming the following domain model
     * public class User {
     *     public Map&lt;String,Address&gt; getAddresses() { ... }
     * }
     *
     * public class Address {
     *     public String getStreet() { ... }
     *     public Country getCountry() { ... }
     * }
     *
     * public class Country {
     *     public String getName() { ... }
     * }
     *
     * //From a property-level constraint on User.addresses
     * //Build a constraint violation on the default path - i.e. the "addresses" property
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addConstraintViolation();
     *
     * //From a class level constraint on Address
     * //Build a constraint violation on the default path + "street"
     * //i.e. the street property of Address
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addPropertyNode( "street" )
     *             .addConstraintViolation();
     *
     * //From a property-level constraint on  User.addresses
     * //Build a constraint violation on the default path + the bean stored
     * //under the "home" key in the map
     * context.buildConstraintViolationWithTemplate( "Incorrect home address" )
     *             .addBeanNode()
     *                 .inIterable().atKey( "home" )
     *             .addConstraintViolation();
     *
     * //From a class level constraint on User
     * //Build a constraint violation on the default path + addresses["home"].country.name
     * //i.e. property "country.name" on the object stored under "home" in the map
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addPropertyNode( "addresses" )
     *             .addPropertyNode( "country" )
     *                 .inIterable().atKey( "home" )
     *             .addPropertyNode( "name" )
     *             .addConstraintViolation();
     * &lt;/pre&gt;
     * &lt;p/&gt;
     * Cross-parameter constraints on a method can create a node specific
     * to a particular parameter if required. Let's explore a few examples:
     * &lt;p/&gt;
     * &lt;pre&gt;
     * //Cross-parameter constraint on method createUser(String password, String passwordRepeat)
     * //Build a constraint violation on the default path + "passwordRepeat"
     * context.buildConstraintViolationWithTemplate("Passwords do not match")
     *             .addParameterNode(1)
     *             .addConstraintViolation();
     *
     * //Cross-parameter constraint on a method
     * //mergeAddresses(Map&lt;String,Address&gt; addresses, Map&lt;String,Address&gt; otherAddresses)
     * //Build a constraint violation on the default path + "otherAddresses["home"]
     * //i.e. the Address bean hosted in the "home" key of the "otherAddresses" map parameter
     * context.buildConstraintViolationWithTemplate(
     *         "Map entry home present in both and does not match")
     *             .addParameterNode(1)
     *             .addBeanNode()
     *                 .inIterable().atKey("home")
     *             .addConstraintViolation();
     *
     * //Cross-parameter constraint on a method
     * //mergeAddresses(Map&lt;String,Address&gt; addresses, Map&lt;String,Address&gt; otherAddresses)
     * //Build a constraint violation on the default path + "otherAddresses["home"].city
     * //i.e. on the "city" property of the Address bean hosted in
     * //the "home" key of the "otherAddresses" map
     * context.buildConstraintViolationWithTemplate(
     *         "Map entry home present in both but city does not match")
     *             .addParameterNode(1)
     *             .addPropertyNode("city")
     *                 .inIterable().atKey("home")
     *             .addConstraintViolation();
     * &lt;/pre&gt;
     *
     * @param messageTemplate new un-interpolated constraint message
     * @return returns a constraint violation builder
     */
    ConstraintViolationBuilder buildConstraintViolationWithTemplate(String messageTemplate);

    /**
     * Returns an instance of the specified type allowing access to
     * provider-specific APIs. If the Bean Validation provider
     * implementation does not support the specified class,
     * {@link ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not support the call
     *
     * @since 1.1
     */
    &lt;T&gt; T unwrap(Class&lt;T&gt; type);

    /**
     * {@link ConstraintViolation} builder allowing to optionally associate
     * the violation report to a sub path.
     * &lt;p/&gt;
     * To create the {@code ConstraintViolation}, one must call either one of
     * the {@code addConstraintViolation()} methods available in one of the
     * interfaces of the fluent API.
     * &lt;p/&gt;
     * If another method is called after {@code addConstraintViolation()} on
     * {@code ConstraintViolationBuilder} or any of its associated objects
     * an {@code IllegalStateException} is raised.
     */
    interface ConstraintViolationBuilder {

        /**
         * Adds a node to the path the {@link ConstraintViolation} will be associated to.
         * &lt;p/&gt;
         * {@code name} describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node {@code name}
         * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)},
         *             {@link #addBeanNode()} and {@link #addParameterNode(int)}
         */
        @Deprecated
        NodeBuilderDefinedContext addNode(String name);

        /**
         * Adds a property node to the path the {@link ConstraintViolation}
         * will be associated to.
         * &lt;p/&gt;
         * {@code name} describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node {@code name}
         * @throws IllegalArgumentException if the name is null
         *
         * @since 1.1
         */
        NodeBuilderCustomizableContext addPropertyNode(String name);

        /**
         * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
         * will be associated to.
         * Note that bean nodes are always leaf nodes.
         *
         * @return a builder representing the bean node
         *
         * @since 1.1
         */
        LeafNodeBuilderCustomizableContext addBeanNode();

        /**
         * Adds a method parameter node to the path the {@link ConstraintViolation}
         * will be associated to.
         * The parameter index must be valid (i.e. within the boundaries of the method
         * parameter indexes). May only be called from within cross-parameter validators.
         *
         * @param index the parameter index
         * @return a builder representing the index-th parameter node
         * @throws IllegalArgumentException if the index is not valid
         *
         * @since 1.1
         */
        NodeBuilderDefinedContext addParameterNode(int index);

        /**
         * Adds the new {@link ConstraintViolation} to be generated if the
         * constraint validator marks the value as invalid.
         * &lt;p/&gt;
         * Methods of this {@code ConstraintViolationBuilder} instance and its nested
         * objects throw {@code IllegalStateException} from now on.
         *
         * @return the {@code ConstraintValidatorContext} instance the
         *         {@code ConstraintViolationBuilder} comes from
         */
        ConstraintValidatorContext addConstraintViolation();

        /**
         * Represents a node whose context is known
         * (i.e. index, key and isInIterable)
         * and that is a leaf node (i.e. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeBuilderDefinedContext {

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator marks the value as invalid.
             * &lt;p/&gt;
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a node whose context is
         * configurable (i.e. index, key and isInIterable)
         * and that is a leaf node (i.e. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeBuilderCustomizableContext {

            /**
             * Marks the node as being in an {@code Iterable} or a {@code Map}.
             * 
             * @return a builder representing iterable details
             */
            LeafNodeContextBuilder inIterable();

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * &lt;p/&gt;
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents refinement choices for a node which is
         * in an {@code Iterator} or {@code Map}.
         * &lt;p/&gt;
         * If the iterator is an indexed collection or a map,
         * the index or the key should be set.
         * &lt;p/&gt;
         * The node is a leaf node (i.e. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeContextBuilder {

            /**
             * Defines the key the object is into the {@code Map}.
             *
             * @param key map key
             * @return a builder representing the current node
             */
            LeafNodeBuilderDefinedContext atKey(Object key);

            /**
             * Defines the index the object is into the {@code List} or array
             *
             * @param index index
             * @return a builder representing the current node
             */
            LeafNodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * &lt;p/&gt;
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a node whose context is known
         * (i.e. index, key and isInIterable)
         * and that is not necessarily a leaf node (i.e. subnodes can
         * be added).
         */
        interface NodeBuilderDefinedContext {

            /**
             * Adds a node to the path the {@link ConstraintViolation} will be associated to.
             * &lt;p/&gt;
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)}
             *             and {@link #addBeanNode()}
             */
            @Deprecated
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             * &lt;p/&gt;
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator marks the value as invalid.
             * &lt;p/&gt;
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a node whose context is
         * configurable (i.e. index, key and isInIterable)
         * and that is not necessarily a leaf node (i.e. subnodes can
         * be added).
         */
        interface NodeBuilderCustomizableContext {

            /**
             * Marks the node as being in an {@code Iterable} or a {@code Map}.
             *
             * @return a builder representing iterable details
             */
            NodeContextBuilder inIterable();

            /**
             * Adds a node to the path the {@link ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)}
             *             and {@link #addBeanNode()}
             */
            @Deprecated
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * &lt;p/&gt;
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents refinement choices for a node which is
         * in an {@code Iterator} or {@code Map}.
         * &lt;p/&gt;
         * If the iterator is an indexed collection or a map,
         * the index or the key should be set.
         * &lt;p/&gt;
         * The node is not necessarily a leaf node (i.e. subnodes can
          * be added).
         */
        interface NodeContextBuilder {
            
            /**
             * Defines the key the object is into the {@code Map}.
             *
             * @param key map key
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atKey(Object key);

            /**
             * Defines the index the object is into the {@code List} or array.
             *
             * @param index index
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Adds a node to the path the {@code ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)}
             *             and {@link #addBeanNode()}
             */
            @Deprecated
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * &lt;p/&gt;
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * &lt;p/&gt;
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }
    }
}</programlisting>

    <para>The <classname>ConstraintValidatorContext</classname> interface
    allows redefinition of the default constraint message generated when a
    constraint is not valid. <phrase role="tck-testable">By default, each
    invalid constraint leads to the generation of one error object represented
    by a <classname>ConstraintViolation</classname> object. This object is
    built from the default constraint message template as defined by the
    constraint declaration and the context in which the constraint declaration
    is placed (bean, property, <phrase revisionflag="added">executable
    parameter, cross-parameter or executable return
    value</phrase>).</phrase></para>

    <para><phrase role="tck-testable">The
    <classname>ConstraintValidatorContext</classname> methods let the
    constraint implementation disable the default
    <classname>ConstraintViolation</classname> generation and create one or
    more custom ones.</phrase> <phrase role="tck-testable">The
    non-interpolated message passed as a parameter is used to build the
    <classname>ConstraintViolation</classname> message (the message
    interpolation operation is applied to it).</phrase></para>

    <para><phrase role="tck-testable tck-needs-update">By default, the
    <classname>Path</classname> exposed on the
    <classname>ConstraintViolation</classname> represents the path to the
    bean, property, <phrase revisionflag="added">parameter, cross-parameter or
    return value</phrase> hosting the constraint (see <xref
    linkend="validationapi-constraintviolation"/> for more
    information).</phrase> <phrase role="tck-testable">You can point it to a
    subpath of this default path by using the constraint violation builder
    fluent API.</phrase></para>

    <para><xref
    linkend="example-constraintsdefinitionimplementation-validationimplementation-errorbuilder"/>
    shows a few examples.</para>

    <example id="example-constraintsdefinitionimplementation-validationimplementation-errorbuilder"
             revisionflag="changed">
      <title>Using the fluent API to build custom constraint
      violations</title>

      <programlisting>//assuming the following domain model
public class User {
    public Map&lt;String,Address&gt; getAddresses() { [...] }
}

public class Address {
    public String getStreet() { [...] }
    public Country getCountry() { [...] }
}

public class Country {
   public String getName() { [...] }
}

//From a property-level constraint on User.addresses
//Build a constraint violation on the default path - i.e. the "addresses" property
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addConstraintViolation();

//From a class level constraint on Address
//Build a constraint violation on the default path + "street"
//i.e. the street property of Address
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addPropertyNode( "street" )
            .addConstraintViolation();

//From a property-level constraint on  User.addresses
//Build a constraint violation on the default path + the bean stored
//under the "home" key in the map
context.buildConstraintViolationWithTemplate( "Incorrect home address" )
            .addBeanNode()
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//From a class level constraint on User
//Build a constraint violation on the default path + addresses["home"].country.name
//i.e. property "country.name" on the object stored under "home" in the map
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addPropertyNode( "addresses" )
            .addPropertyNode( "country" )
                .inIterable().atKey( "home" )
            .addPropertyNode( "name" )
            .addConstraintViolation();

//To create a subnode representing a method parameter from a cross-parameter constraint violation

//Cross-parameter constraint on method createUser(String password, String passwordRepeat)
//Build a constraint violation on the default path + "passwordRepeat"
context.buildConstraintViolationWithTemplate("Passwords do not match")
            .addParameterNode(1)
            .addConstraintViolation();

//Cross-parameter constraint on a method
//mergeAddresses(Map&lt;String,Address&gt; addresses, Map&lt;String,Address&gt; otherAddresses)
//Build a constraint violation on the default path + "otherAddresses["home"]
//i.e. the Address bean hosted in the "home" key of the "otherAddresses" map parameter
context.buildConstraintViolationWithTemplate(
        "Map entry home present in both and does not match" )
            .addParameterNode( 1 )
            .addBeanNode()
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//Cross-parameter constraint on a method
//mergeAddresses(Map&lt;String,Address&gt; addresses, Map&lt;String,Address&gt; otherAddresses)
//Build a constraint violation on the default path + "otherAddresses["home"].city
//i.e. on the "city" property of the Address bean hosted in
//the "home" key of the "otherAddresses" map
context.buildConstraintViolationWithTemplate(
        "Map entry home present in both but city does not match" )
            .addParameterNode( 1 )
            .addPropertyNode( "city" )
                .inIterable().atKey( "home" )
            .addConstraintViolation();</programlisting>
    </example>

    <para role="tck-testable">If
    <methodname>disableDefaultConstraintViolation()</methodname> is called, no
    custom error is added (using the error builder) and if the constraint is
    not valid, a <classname>ValidationException</classname> is raised.</para>

    <section id="constraintsdefinitionimplementation-validationimplementation-example">
      <title revisionflag="changed">Examples</title>

      <example>
        <title>ConstraintValidator implementation</title>

        <programlisting>/**
 * Check that a text is within the authorized syntax
 */
public class SyntaxValidator implements ConstraintValidator&lt;Syntax, String&gt; {
    private Set&lt;Format&gt; allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;

        return allowedFormats.size() == 0 
            || (! Collections.disjoint( guessFormat(value), allowedFormats ) );
    }

    Set&lt;Format&gt; guessFormats(String text) { [...] }
}</programlisting>
      </example>

      <para>This <classname>ConstraintValidator</classname> checks that a text
      is within the accepted syntax. It also demonstrates an interesting best
      practice: return <literal>true</literal> on a null parameter.</para>

      <para revisionflag="added">The following listing shows a validator
      implementing the validation logic for a cross-parameter
      constraint.</para>

      <example revisionflag="added">
        <title>Cross-parameter validator implementation</title>

        <programlisting>/**
 * Check that two date parameters of a method are in the expected order. Expects the
 * 2nd and 3rd parameter of the validated method to be of type java.util.Date.
 */
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class DateParametersConsistentValidator implements&lt;DateParametersConsistent, Object[]&gt; {

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(DateParametersConsistent constraint) {
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(Object[] value, ConstraintValidatorContext context) {
        if ( value.length != 3 ) {
            throw new IllegalStateException( "Unexpected method signature" );
        }
        // one or both limits are unbounded =&gt; always consistent
        if ( value[1] == null || value[2] == null ) return true;
        return ( (Date) value[1] ).before( (Date) value[2] );
    }
}</programlisting>
      </example>

      <para>The following listing shows a validator implementing the
      validation logic for a constraint that is both generic and
      cross-parameter.</para>

      <example revisionflag="added">
        <title>Generic and cross-parameter validator implementation</title>

        <programlisting>/**
 * Checks that an object passes the Expression Language expression
 * provided by the constraint.
 */
@SupportedValidationTarget({ValidationTarget.ANNOTATED_ELEMENT, ValidationTarget.PARAMETERS})
public class ELScriptValidator implements&lt;ELScript, Object&gt; {

    public void initialize(ELScript constraint) {
        [...]
    }

    public boolean isValid(Object value, ConstraintValidatorContext context) {
        [...]
    }
}</programlisting>
      </example>

      <para>The next example shows how to use
      <classname>ConstraintValidatorContext</classname>.</para>

      <example>
        <title>Use of ConstraintValidatorContext</title>

        <programlisting>/**
 * Check that a text is within the authorized syntax
 * Error messages are using either key:
 *  - com.acme.constraint.Syntax.unknown if no particular syntax is detected
 *  - com.acme.constraint.Syntax.unauthorized if the syntax is not allowed
 */
public class FineGrainedSyntaxValidator implements ConstraintValidator&lt;Syntax, String&gt; {
    private Set&lt;Format&gt; allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;
        Set&lt;Format&gt; guessedFormats = guessFormats(value);

        context.disableDefaultConstraintViolation();
        if ( guessedFormats.size() == 0 ) {
            String unknown = "{com.acme.constraint.Syntax.unknown}";
            context.buildConstraintViolationWithTemplate(unknown)
                       .addConstraintViolation();
            return false;
        }
        if ( allowedFormats.size() != 0 
            &amp;&amp; Collections.disjoint( guessedFormats, allowedFormats ) ) {

            String unauthorized = "{com.acme.constraint.Syntax.unauthorized}";
            context.buildConstraintViolationWithTemplate(unauthorized)
                       .addConstraintViolation();
            return false;
        }
        return true;
    }

    Set&lt;Format&gt; guessFormats(String text) { [...] }
}</programlisting>
      </example>

      <para>The default error message is disabled and replaced by a specific
      error message depending on the type of constraint violation detected. In
      this case, only one error report is returned at a given time but a
      constraint validation implementation can return several error
      reports.</para>
    </section>
  </section>

  <section id="constraintsdefinitionimplementation-constraintfactory">
    <title>The ConstraintValidatorFactory</title>

    <para>Constraint validation implementation instances are created by a
    <classname>ConstraintValidatorFactory</classname>.</para>

    <para revisionflag="added">The life cycle of
    <classname>ConstraintValidator</classname> instances is fully dependent of
    the Bean Validation provider and piloted by the
    <classname>ConstraintValidatorFactory</classname> methods. Therefore,
    <classname>ConstraintValidatorFactory</classname> implementations (such as
    dependency injection frameworks) must consider these instances as
    belonging to a dependent scope. <phrase role="tck-testable">Bean
    Validation providers must release each instance retrieved. The
    <classname>ConstraintValidatorFactory</classname> instance that has
    created a <classname>ConstraintValidator</classname> instance must be the
    one that releases it. In other words, passing an instance of
    <classname>ConstraintValidator</classname> to a
    <classname>ConstraintValidatorFactory</classname> that has not created it
    is an error.</phrase></para>

    <note revisionflag="added">
      <para revisionflag="added"><classname>ConstraintValidator</classname>
      instances created by the <classname>ValidatorFactory</classname>-level
      <classname>ConstraintValidatorFactory</classname> can be released when
      the <classname>ValidatorFactory</classname> is being closed.</para>
    </note>

    <example revisionflag="changed">
      <title>ConstraintValidatorFactory interface</title>

      <programlisting>/**
 * Instantiates a {@link ConstraintValidator} instance based off its class.
 * The {@code ConstraintValidatorFactory} is &lt;b&gt;not&lt;/b&gt; responsible
 * for calling {@link ConstraintValidator#initialize(java.lang.annotation.Annotation)}.
 *
 * @author Dhanji R. Prasanna
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidatorFactory {

    /**
     * @param key The class of the constraint validator to instantiate
     *
     * @return A new constraint validator instance of the specified class
     */
    &lt;T extends ConstraintValidator&lt;?, ?&gt;&gt; T getInstance(Class&lt;T&gt; key);

    /**
     * Signals {@code ConstraintValidatorFactory} that the instance is no longer
     * being used by the Bean Validation provider.
     *
     * @param instance validator being released
     *
     * @since 1.1
     */
    void releaseInstance(ConstraintValidator&lt;?, ?&gt; instance);
}</programlisting>
    </example>

    <para revisionflag="changed"><phrase role="tck-testable">The default
    <classname>ConstraintValidatorFactory</classname> provided by the Bean
    Validation provider implementation uses the public no-arg constructor of
    the <classname>ConstraintValidator</classname> class.</phrase> A custom
    <classname>ConstraintValidatorFactory</classname> can be provided; for
    example it may benefit from dependency injection control in constraint
    implementations (see <xref
    linkend="bootstrapping-usageandcontainerexpectation"/>). Any constraint
    implementation relying on
    <classname>ConstraintValidatorFactory</classname> behaviors specific to an
    implementation (dependency injection, no no-arg constructor and so on) are
    not portable, hence great care should be given before walking that path.
    Make sure to configure the Bean Validation provider to honor any specific
    needs your <classname>ConstraintValidator</classname> has. As constraint
    designer and writer, make sure to document any specific non compliant
    requirements.</para>

    <para><classname>ConstraintValidatorFactory</classname> should not cache
    instances as the state of each instance can be altered in the
    <methodname>initialize()</methodname> method.</para>

    <para><phrase role="tck-testable">If an exception occurs in the factory
    while retrieving the <classname>ConstraintValidator</classname> instance,
    the runtime exception is wrapped in a
    <classname>ValidationException</classname>.</phrase> <phrase
    role="tck-testable">If the instance returned by the factory is null, a
    <classname>ValidationException</classname> is raised.</phrase></para>
  </section>
</chapter>
