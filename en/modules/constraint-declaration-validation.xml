<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../docbook-support/support/docbook-dtd/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../global.ent">
%BOOK_ENTITIES;
]>
<chapter id="constraintdeclarationvalidationprocess">
  <title>Constraint declaration and validation process</title>

  <para revisionflag="changed">The Bean Validation specification defines a
  framework for declaring constraints on JavaBean classes, fields and
  properties. Constraints are declared on types and evaluated against
  instances or graphs of instances.</para>

  <para revisionflag="added">Bean Validation also offers a way to declare
  constructor and method constraints where parameters and return values are
  the constrained elements. We will discuss method constraints declaration in
  detail in <xref
  linkend="constraintdeclarationvalidationprocess-methodlevelconstraints"/>.</para>

  <section id="constraintdeclarationvalidationprocess-requirements">
    <title>Requirements on classes to be validated</title>

    <para revisionflag="changed">Objects hosting constraints and expecting to
    be validated by Bean Validation providers must fulfill the following
    requirements:</para>

    <itemizedlist>
      <listitem>
        <para role="tck-testable">Properties to be validated must follow the
        method signature conventions for JavaBeans read properties, <phrase
        revisionflag="changed">as defined by the <ulink
        url="http://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/">JavaBeans
        specification</ulink></phrase>. <phrase revisionflag="added">These
        properties are commonly referred as getters</phrase>.</para>
      </listitem>

      <listitem>
        <para role="tck-not-testable">Static fields and static methods are
        excluded from validation.</para>
      </listitem>

      <listitem>
        <para role="tck-testable">Constraints can be applied to interfaces and
        superclasses.</para>
      </listitem>
    </itemizedlist>

    <note role="tck-testable">
      <title>What is a getter?</title>

      <para>The JavaBeans specification specifies that a getter is a method
      whose</para>

      <itemizedlist>
        <listitem>
          <para>name starts with <literal>get</literal> and has a return type
          but no parameter</para>
        </listitem>

        <listitem>
          <para>name starts with <literal>is</literal>, has no parameter and
          is returning <classname>Boolean</classname></para>
        </listitem>
      </itemizedlist>
    </note>

    <para role="tck-testable">The target of an annotation definition can be a
    field, property, type, constructor or method return value, constructor or
    method parameter or constructor or method cross-parameter provided that:
    <itemizedlist>
        <listitem>
          <para>the constraint definition supports the specified target
          (<classname>java.lang.annotation.Target</classname>)</para>
        </listitem>

        <listitem>
          <para>one of the <classname>ConstraintValidator</classname>s
          declared on the constraint supports the declared type of the target
          or in the case of cross-parameter, one cross-parameter
          <classname>ConstraintValidator</classname> is present (see <xref
          linkend="typevalidatorresolution"/> to learn about
          <classname>ConstraintValidator</classname> resolution).</para>
        </listitem>
      </itemizedlist></para>

    <section id="constraintdeclarationvalidationprocess-requirements-object">
      <title>Object validation</title>

      <para><phrase role="tck-testable">Constraint declarations can be applied
      to a class or an interface.</phrase> Applying a constraint to a class or
      interface expresses a validation over the state of the class or the
      class implementing the interface.</para>
    </section>

    <section id="constraintdeclarationvalidationprocess-requirements-property">
      <title>Field and property validation</title>

      <para><phrase role="tck-testable">Constraint declarations can be applied
      on both fields and properties for the same object type.</phrase> <phrase
      role="tck-testable">The same constraint should however not be duplicated
      between a field and its associated property (the constraint validation
      would be applied twice).</phrase> It is recommended for objects holding
      constraint declarations to adhere to a single state access strategy
      (either annotated fields or properties).</para>

      <note>
        <title>Java Persistence and Bean Validation</title>

        <para>For maximum portability, persistent properties hosting Bean
        Validation constraints should use the same access strategy used in
        Java Persistence. In other words, place your Bean Validation
        constraint annotations on the same element (field or getter) as your
        Java Persistence annotations.</para>
      </note>

      <para role="tck-testable">When a field is annotated with a constraint
      declaration, field access strategy is used to access the state validated
      by such constraint.</para>

      <para role="tck-testable">When a property is annotated with a constraint
      declaration, property access strategy is used to access the state
      validated by such constraint.</para>

      <para>When using field access strategy, the bean validation provider
      accesses the instance variable directly. When using the property access
      strategy, the bean validation provider accesses the state via the
      property accessor method. It is required that the class follows the
      method signature conventions for JavaBeans read properties (as defined
      by the JavaBeans <classname>Introspector</classname> class) for
      constrained properties when constrained properties are used. In this
      case, for every constraint property of type <classname>T</classname>,
      there is a getter method named
      <methodname>get&lt;Property-name&gt;</methodname>. <phrase
      revisionflag="added">The method must have no parameters.</phrase> For
      <code>Boolean</code> properties,
      <methodname>is&lt;Property-name&gt;</methodname> is an alternative name
      for the getter method. Specifically, if <methodname>getX</methodname> is
      the name of the getter method, where <classname>X</classname> is a
      string, the name of the persistent property is defined by the result of
      <code>java.beans.Introspector.decapitalize(X)</code>.</para>

      <para><phrase role="tck-testable">The fields or methods visibility are
      not constrained.</phrase></para>
    </section>

    <section id="constraintdeclarationvalidationprocess-requirements-graphvalidation">
      <title>Graph validation</title>

      <para>In addition to supporting instance validation, validation of
      graphs of object is also supported. The result of a graph validation is
      returned as a unified set of constraint violations. <phrase
      revisionflag="added"><classname>@Valid</classname> is used to express
      validation traversal of an association.</phrase><example
          revisionflag="added">
          <title><classname>@Valid</classname> annotation</title>

          <programlisting language="JAVA" role="JAVA">/**
 * Mark a property, method parameter or method return type for validation cascading.
 *
 * Constraints defined on the object and its properties are be validated when the
 * property, method parameter or method return type is validated.
 *
 * This behavior is applied recursively.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
@Target({ METHOD, FIELD, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Valid {
}</programlisting>
        </example></para>

      <para><phrase role="tck-testable">Consider the situation where bean
      <classname>X</classname> contains a field of type
      <classname>Y</classname>. By annotating field <classname>Y</classname>
      with the <classname>@Valid</classname> annotation, the Validator will
      validate <classname>Y</classname> (and its properties) when
      <classname>X</classname> is validated.</phrase> <phrase
      role="tck-testable">The exact type <classname>Z</classname> of the value
      contained in the field declared of type <classname>Y</classname>
      (subclass, implementation) is determined at runtime. The constraint
      definitions of <classname>Z</classname> are used.</phrase> This ensures
      proper polymorphic behavior for associations marked
      <classname>@Valid</classname>.</para>

      <para>Collection-valued, array-valued and generally
      <classname>Iterable</classname> fields and properties may also be
      decorated with the <classname>@Valid</classname> annotation. This causes
      the contents of the iterator to be validated. <phrase
      role="tck-testable">Any object implementing
      <classname>java.lang.Iterable</classname> is supported.</phrase> This
      includes specifically:</para>

      <itemizedlist>
        <listitem>
          <para role="tck-testable">arrays of objects</para>
        </listitem>

        <listitem>
          <para
          role="tck-testable"><classname>java.util.Collection</classname></para>
        </listitem>

        <listitem>
          <para
          role="tck-testable"><classname>java.util.Set</classname></para>
        </listitem>

        <listitem>
          <para
          role="tck-testable"><classname>java.util.List</classname></para>
        </listitem>

        <listitem>
          <para><phrase
          role="tck-testable"><classname>java.util.Map</classname></phrase>
          (special treatment see below)</para>
        </listitem>
      </itemizedlist>

      <para>Each object provided by the iterator is validated. <phrase
      role="tck-testable">For <classname>Map</classname>, the value (retrieved
      by <methodname>getValue</methodname>) of each
      <classname>Map.Entry</classname> is validated (the key is not
      validated).</phrase></para>

      <para role="tck-testable">Like regular references, its type is
      determined at runtime and the constraint definitions for this particular
      type are used.</para>

      <para><phrase role="tck-testable">The <classname>@Valid</classname>
      annotation is applied recursively.</phrase> A conforming implementation
      avoids infinite loops according to the rules described in <xref
      linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"/>.</para>
    </section>
  </section>

  <section>
    <title>Constraint declaration</title>

    <para>Constraint declarations are placed on classes or interfaces
    primarily through annotations. A constraint annotation (see <xref
    linkend="constraintsdefinitionimplementation-constraintdefinition"/>), can
    be applied to a type, on any of the type's fields or on any of the
    JavaBeans-compliant properties.</para>

    <para>When a constraint is defined on a class, the class instance being
    validated is passed to the <classname>ConstraintValidator</classname>.
    When a constraint is defined on a field, the value of the field is passed
    to the <classname>ConstraintValidator</classname>. When a constraint is
    defined on a getter, the result of the getter invocation is passed to the
    <classname>ConstraintValidator</classname>.</para>

    <para><xref
    linkend="constraintdeclarationvalidationprocess-methodlevelconstraints"/>
    discusses in detail constraints on methods and constructors.</para>
  </section>

  <section id="constraintdeclarationvalidationprocess-inheritance">
    <title>Inheritance (interface and superclass)</title>

    <para><phrase role="tck-testable">A constraint declaration can be placed
    on an interface.</phrase> <phrase role="tck-testable">For a given class,
    constraint declarations held on superclasses as well as interfaces are
    evaluated by the Bean Validation provider.</phrase> Rules are formally
    described in <xref
    linkend="constraintdeclarationvalidationprocess-groupsequence-formaldefinition"/>.</para>

    <para>The effect of constraint declarations is cumulative. Constraints
    declared on a superclass getter will be validated along with any
    constraints defined on an overridden version of the getter according to
    the Java Language Specification visibility rules.</para>
  </section>

  <section id="constraintdeclarationvalidationprocess-groupsequence">
    <title>Group and group sequence</title>

    <para>A group defines a subset of constraints. Instead of validating all
    constraints for a given object graph, only a subset is validated. This
    subset is defined by the the group or groups targeted. Each constraint
    declaration defines the list of groups it belongs to. <phrase
    role="tck-testable">If no group is explicitly declared, a constraint
    belongs to the <classname>Default</classname> group.</phrase></para>

    <para role="tck-testable">Groups are represented by interfaces.</para>

    <example>
      <title>Definition of groups</title>

      <programlisting>/**
 * Validation group verifing that a user is billable
 */
public interface Billable {}

/**
 * Customer can buy without any harrassing checking process
 */
public interface BuyInOneClick {
}</programlisting>
    </example>

    <para role="tck-testable">A constraint can belong to one or more
    groups.</para>

    <example id="example-assigngrouptoconstraints">
      <title>Assign groups to constraints</title>

      <programlisting>/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = {Billable.class, BuyInOneClick.class})
    private CreditCard defaultCreditCard;
}</programlisting>
    </example>

    <para><phrase role="tck-testable">During the validation call, one or more
    groups are validated. All the constraints belonging to this set of group
    is evaluated on the object graph.</phrase> In <xref
    linkend="example-assigngrouptoconstraints"/>,
    <classname>@NotNull</classname> is checked on
    <literal>defaultCreditCard</literal> when either the
    <classname>Billable</classname> or <classname>BuyInOneClick</classname>
    group is validated. <classname>@NotNull</classname> on
    <literal>firstname</literal> and <literal>lastname</literal> are validated
    when the <classname>Default</classname> group is validated. Reminder:
    constraints held on superclasses and interfaces are considered.</para>

    <para><classname>Default</classname> is a group predefined by the
    specification</para>

    <programlisting>package javax.validation.groups;

/**
 * Default Bean Validation group.
 * Unless a list of group is explicitly defined:
 * &lt;ul&gt;
 *  &lt;li&gt;constraints belong to the Default group&lt;/li&gt;
 *  &lt;li&gt;validation apply on the Default group&lt;/li&gt;
 * &lt;/ul&gt;
 * Most structural constraints should belong to the default group.
 *
 * @author Emmanuel Bernard
 */
public interface Default {
}</programlisting>

    <section id="constraintdeclarationvalidationprocess-groupsequence-groupinheritance">
      <title>Group inheritance</title>

      <para>In some situations, a group is a superset of one or more groups.
      This can be described by Bean Validation. <phrase role="tck-testable">A
      group may inherit one or more groups by using interface
      inheritance.</phrase></para>

      <example>
        <title>Groups can inherit other groups</title>

        <programlisting>/**
 * Customer can buy without harrassing checking process
 */
public interface BuyInOneClick extends Default, Billable {}</programlisting>
      </example>

      <para role="tck-testable">For a given interface
      <classname>Z</classname>, constraints marked as belonging to the group
      <classname>Z</classname> (i.e. where the annotation element
      <methodname>groups</methodname> contains the interface
      <classname>Z</classname>) or any of the super interfaces of
      <classname>Z</classname> (inherited groups) are considered part of the
      group <classname>Z</classname>.</para>

      <para>In the following example:</para>

      <example>
        <title>Use of a inherited group</title>

        <programlisting>/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = Billable.class)
    private CreditCard defaultCreditCard;
}</programlisting>
      </example>

      <para>validating the group <classname>BuyInOneClick</classname> will
      lead to the following constraints checking:</para>

      <itemizedlist>
        <listitem>
          <para><classname>@NotNull</classname> on
          <literal>firstname</literal> and <literal>lastname</literal></para>
        </listitem>

        <listitem>
          <para><classname>@NotNull</classname> on
          <literal>defaultCreditCard</literal></para>
        </listitem>
      </itemizedlist>

      <para>because <classname>Default</classname> and
      <classname>Billable</classname> are superinterfaces of
      <classname>BuyInOneClick</classname>.</para>
    </section>

    <section id="constraintdeclarationvalidationprocess-groupsequence-groupsequence">
      <title>Group sequence</title>

      <para><phrase role="tck-not-testable">By default, constraints are
      evaluated in no particular order regardless of which groups they belong
      to.</phrase> It is however useful in some situations to control the
      order of constraints evaluation. There are often scenarios where a
      preliminary set of constraints should be evaluated prior to other
      constraints. Here are two examples:</para>

      <itemizedlist>
        <listitem>
          <para>The second group depends on a stable state to run properly.
          This stable state is verified by the first group.</para>
        </listitem>

        <listitem>
          <para>The second group is a heavy consumer of time, CPU or memory
          and its evaluation should be avoided if possible.</para>
        </listitem>
      </itemizedlist>

      <para>To implement such ordering, a group can be defined as a sequence
      of other groups. <phrase role="tck-testable">Each group in a group
      sequence must be processed sequentially in the order defined by
      <methodname>@GroupSequence.value</methodname> when the group defined as
      a sequence is requested.</phrase> <phrase role="tck-testable">Note that
      a group member of a sequence can itself be composed of several groups
      via inheritance or sequence definition. In this case, each composed
      group must respect the sequence order as well.</phrase></para>

      <!--TODO add example-->

      <para>Processing a group is defined in <xref
      linkend="constraintdeclarationvalidationprocess-validationroutine"/> ;
      <phrase role="tck-testable">if one of the groups processed in the
      sequence generates one or more constraint violations, the groups
      following in the sequence must not be processed.</phrase> This ensures
      that a set of constraint is evaluated only if another set of constraint
      is valid.</para>

      <para role="tck-testable">Groups defining a sequence and groups
      composing a sequence must not be involved in a cyclic dependency:
      <itemizedlist>
          <listitem>
            <para>either directly or indirectly</para>
          </listitem>

          <listitem>
            <para>either through cascaded sequence definitions or group
            inheritance</para>
          </listitem>
        </itemizedlist></para>

      <para role="tck-testable">If a group containing such a circularity is
      evaluated, a <classname>GroupDefinitionException</classname> is
      raised.</para>

      <para role="tck-not-testable">Groups defining a sequence should not
      directly inherit other groups. In other words, the interface hosting the
      group sequence should not have any super interface.</para>

      <para><phrase role="tck-not-testable">Groups defining a sequence should
      not be used directly in constraint declarations.</phrase> In other
      words, the interface hosting the group sequence should not be used in a
      constraint declaration.</para>

      <para role="tck-testable">To define a group as a sequence, the interface
      must be annotated with the <classname>@GroupSequence</classname>
      annotation.</para>

      <programlisting>/**
 * Define a group sequence
 * The interface hosting {@code @GroupSequence} is representing
 * the group sequence.
 * When hosted on a class, represents the {@code Default} group
 * for that class.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
@Target({ TYPE })
@Retention(RUNTIME)
public @interface GroupSequence {
    Class&lt;?&gt;[] value();
}</programlisting>

      <para>Here is a usage example</para>

      <example id="example-groupsequence">
        <title>Make use of group sequence</title>

        <programlisting>@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @NotNull @ZipCode
    private String zipcode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check coherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}

    /**
     * check both basic constraints and high level ones.
     * high level constraints are not checked if basic constraints fail
     */
    @GroupSequence({Default.class, HighLevelCoherence.class})
    public interface Complete {}
}</programlisting>
      </example>

      <para>In <xref linkend="example-groupsequence"/>, when the
      <classname>Address.Complete</classname> group is validated, all
      constraints belonging to the <classname>Default</classname> group are
      validated. If any of them fail, the validation skips the
      <classname>HighLevelCoherence</classname> group. If all
      <classname>Default</classname> constraints pass,
      <classname>HighLevelCoherence</classname> constraints are
      evaluated.</para>

      <note>
        <para><phrase role="tck-testable">A given constraint can belong to two
        or more groups ordered by a sequence. In this case, the constraint is
        evaluated as part of the first group and ignored in the subsequent
        group(s).</phrase> See <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine"/>
        for more information.</para>
      </note>

      <!--Make explicit what happens if a group is part of a group sequence and also explicitly called in validator.validate()-->
    </section>

    <section id="constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup">
      <title>Redefining the Default group for a class</title>

      <para>In <xref linkend="example-groupsequence"/>, validating the
      <classname>Default</classname> group does not validate
      <classname>HighLevelCoherence</classname> constraints. To ensure a
      complete validation, a user must use the <classname>Complete</classname>
      group. This breaks some of the encapsulation you could expect. You can
      work around this by redefining what the <classname>Default</classname>
      group means for a given class. <phrase role="tck-testable">To redefine
      <classname>Default</classname> for a class, place a
      <classname>@GroupSequence</classname> annotation on the class; this
      sequence expresses the sequence of groups that does substitute
      <classname>Default</classname> for this class.</phrase></para>

      <example id="example-overridedefaultgroup">
        <title>Redefining Default group for Address</title>

        <programlisting>@GroupSequence({Address.class, HighLevelCoherence.class})
@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @NotNull @ZipCode
    private String zipcode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check coherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}
}</programlisting>
      </example>

      <para>In <xref linkend="example-overridedefaultgroup"/>, when an address
      object is validated for the group <classname>Default</classname>, all
      constraints belonging to the group <classname>Default</classname> and
      hosted on <classname>Address</classname> are evaluated. If none fails,
      all <classname>HighLevelCoherence</classname> constraints present on
      <classname>Address</classname> are evaluated. In other words, when
      validating the <classname>Default</classname> group for
      <classname>Address</classname>, the group sequence defined on the
      <classname>Address</classname> class is used.</para>

      <para>Since sequences cannot have circular dependencies, using
      <classname>Default</classname> in the declaration of a sequence is not
      an option. <phrase role="tck-not-testable">Constraints hosted on a class
      <classname>A</classname> and belonging to the
      <classname>Default</classname> group (by default or explicitly)
      implicitly belong to the group <classname>A</classname>.</phrase></para>

      <para><phrase role="tck-testable">A sequence defined on a class
      <classname>A</classname> (i.e. redefining the
      <classname>Default</classname> groups for the class) must contain the
      group <classname>A</classname>.</phrase> In other words, the default
      constraints hosted on a class must be part of the sequence definition.
      <phrase role="tck-testable">If a <classname>@GroupSequence</classname>
      redefining the <classname>Default</classname> group for a class
      <classname>A</classname> does not contain the group
      <classname>A</classname>, a
      <classname>GroupDefinitionException</classname> is raised when the class
      is validated or when its metadata is requested.</phrase></para>
    </section>

    <section id="constraintdeclarationvalidationprocess-groupsequence-implicitgrouping">
      <title>Implicit grouping</title>

      <para>It is possible to implicitly group several constraints in the same
      group without explicitly listing such a group in the constraint
      declaration. <phrase role="tck-testable">Every constraint hosted on an
      interface <classname>Z</classname> and part of the
      <classname>Default</classname> group (implicitly or explicitly) belongs
      to the group <classname>Z</classname>.</phrase> This is useful to
      validate the partial state of an object based on a role represented by
      an interface.</para>

      <example>
        <title>Example of interface / group hosting constraints</title>

        <programlisting>/**
 * Auditable object contract
 */
public interface Auditable {
    @NotNull String getCreationDate();
    @NotNull String getLastUpdate();
    @NotNull String getLastModifier();
    @NotNull String getLastReader();
}

/**
 * Represents an order in the system
 */
public class Order implements Auditable {
    private String creationDate;
    private String lastUpdate;
    private String lastModifier;
    private String lastReader;

    private String orderNumber;

    public String getCreationDate() {
        return this.creationDate;
    }

    public String getLastUpdate() {
        return this.lastUpdate;
    }

    public String getLastModifier() {
        return this.lastModifier;
    }

    public String getLastReader() {
        return this.lastReader;
    }

    @NotNull @Size(min=10, max=10)
    public String getOrderNumber() {
        return this.orderNumber;
    }
}</programlisting>
      </example>

      <para>When an <classname>Order</classname> object is validated on the
      <classname>Default</classname> group, the following constraints are
      validated: <classname>@NotNull</classname> on
      <methodname>getCreationDate</methodname>,
      <methodname>getLastUpdate</methodname>,
      <methodname>getLastModifier</methodname>,
      <methodname>getLastReader</methodname>,
      <methodname>getOrderNumber</methodname> and <classname>@Size</classname>
      on <methodname>getOrderNumber</methodname> as all belong to the
      <classname>Default</classname> group.</para>

      <para>When an <classname>Order</classname> object is validated on the
      <classname>Auditable</classname> group, the following constraints are
      validated: <classname>@NotNull</classname> on
      <methodname>getCreationDate</methodname>,
      <methodname>getLastUpdate</methodname>,
      <methodname>getLastModifier</methodname>,
      <methodname>getLastReader</methodname>. Only the constraints present on
      <classname>Auditable</classname> (and any of its super interfaces) and
      belonging to the <classname>Default</classname> group are validated when
      the group <classname>Auditable</classname> is requested. It allows the
      caller to validate that a given object can be safely audited even if the
      object state itself is not valid.</para>
    </section>

    <section id="constraintdeclarationvalidationprocess-groupsequence-groupconversion"
             revisionflag="added">
      <title>Group conversion</title>

      <para>When performing cascading validation, it is possible to use a
      different group than the one originally requested using the group
      conversion feature. Group conversions are declared by using the
      <classname>@ConvertGroup</classname> annotation.</para>

      <example>
        <title>@ConvertGroup annotation</title>

        <programlisting language="JAVA" role="JAVA">package javax.validation.groups;

/**
 * Convert group {@code from} to group {@code to} during cascading.
 * 
 * Can be used everywhere {@link Valid} is used and must be on an element
 * annotated with {@link Valid}.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
@Target({ TYPE, METHOD, FIELD, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
public @interface ConvertGroup {
    Class&lt;?&gt; from();
    Class&lt;?&gt; to();

    /**
     * Defines several {@code ConvertGroup} annotations
     * on the same element
     */
    @Target({ TYPE, METHOD, FIELD, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    public @interface List {
        ConvertGroup[] value();
    }
}</programlisting>
      </example>

      <para role="tck-testable"><classname>@ConvertGroup</classname> and
      <classname>@ConvertGroup.List</classname> can be used everywhere
      <classname>@Valid</classname> can be used (associations,
      method/constructor parameters and return value). If these annotations
      are used without <classname>@Valid</classname>, a
      <classname>ConstraintDeclarationException</classname> is raised.</para>

      <para>When an element is annotated with <classname>@Valid</classname>,
      validation is propagated. Groups are passed as is to the nested elements
      unless the <classname>@ConvertGroup</classname> annotation is
      used.</para>

      <para role="tck-testable">If the group expected to be passed to the
      nested element validation is defined as the <literal>from</literal>
      attribute of a <classname>@ConvertGroup</classname> annotation, the
      group used to effectively validate the nested element is the
      corresponding group defined in the <literal>to</literal>
      attribute.</para>

      <para><phrase role="tck-testable">Rules are not executed
      recursively.</phrase> If a rule is found matching, subsequent rules are
      no longer evaluated. In particular, if a set of
      <classname>@ConvertGroup</classname> declaration chains group
      <literal>A</literal> to <literal>B</literal> and <literal>B</literal> to
      <literal>C</literal>, the group <literal>A</literal> will be converted
      to <literal>B</literal> and not to <literal>C</literal>. This both makes
      rules clearer and let you switch two groups.</para>

      <para role="tck-testable">It is not legal to have more than one
      conversion rule containing the same <literal>from</literal> value. In
      this case, a <classname>ConstraintDeclarationException</classname> is
      raised.</para>

      <para><phrase role="tck-testable">Like regular constraint declarations,
      the <literal>from</literal> attribute cannot refer to a group sequence.
      A <classname>ConstraintDeclarationException</classname> is raised in
      this situation.</phrase> <phrase role="tck-testable">The
      <literal>to</literal> attribute can. The group sequence will then be
      expanded before validating the associated object.</phrase></para>

      <note>
        <para>When validation is done, group sequences are expanded before
        validating the object and its cascaded objects with the expected
        groups. Group conversion on an associated object happens on the
        already expanded groups.</para>

        <para>The group referred to in
        <methodname>@ConvertGroup.from</methodname> works on expanded groups
        (i.e., after the group sequence has been expanded), not necessarily
        groups passed to the various <methodname>validate</methodname>
        methods</para>

        <para>The group referred to in
        <methodname>@ConvertGroup.to</methodname> will be expanded before
        validating the cascaded object just like a call to the various
        <methodname>validate</methodname> method would have done.</para>
      </note>

      <note>
        <para>Like most Bean Validation error cases, an illegal set of rules
        can be discovered statically (at compile time). For example, an
        annotation processor could detect such errors.</para>
      </note>

      <note>
        <para>Group circularity in a group conversion are not problematic
        because:</para>

        <itemizedlist>
          <listitem>
            <para>only one rule is applied for a given cascade (rules are not
            applied recursively)</para>
          </listitem>

          <listitem>
            <para>validation cascading is stopped when the same instance /
            property is validated with the same group in a given path
            (existing rule)</para>
          </listitem>
        </itemizedlist>
      </note>

      <para><phrase role="tck-testable"><classname>@ConvertGroup</classname>
      and <classname>@ConvertGroup.List</classname> can only be placed where
      <classname>@Valid</classname> is present to ensure proper respect of the
      Liskov substitution principle:</phrase> if rules were to be defined on
      an overriding method of a method marked as cascading validation, the
      rules could end up altering the list of constraints validated by the
      super type and thus violating the Liskov substitution principle.</para>

      <para><phrase role="tck-testable">Likewise, if a sub type
      overrides/implements a method originally defined in several parallel
      types of the hierarchy (e.g. two interfaces not extending each other, or
      a class and an interface not implemented by said class) and if that
      method's return value has been marked for cascading validation in one of
      the parallel types, no group conversion rule may be declared for that
      method's return value in the parallel types of the hierarchy.</phrase>
      This again is to avoid an unexpected altering of the post conditions to
      be guaranteed to the caller.</para>

      <para role="tck-testable">If any of these rules is violated, a
      <classname>ConstraintDeclarationException</classname> is raised by
      default as defined in <xref
      linkend="constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance"/>.</para>

      <para>Group conversion is quite useful to facilitate object graph reuse
      without spreading the validation group definitions across several
      layers. Let's look at an example.</para>

      <section>
        <title>Group conversion examples</title>

        <para>In this example we will reuse the <classname>Address</classname>
        group split and match it to the <classname>User</classname> group
        split.</para>

        <example>
          <title>Example of group conversion</title>

          <programlisting language="JAVA" role="JAVA">public interface Complete extends Default {}
public interface BasicPostal {}
public interface FullPostal extends BasicPostal {}

public class Address {
    @NotNull(groups=BasicPostal.class)
    String street1;

    String street2;

    @ZipCode(groups=BasicPostal.class)
    String zipCode;

    @CodeChecker(groups=FullPostal.class)
    String doorCode;
}

public class User {
    @Valid
    @ConvertGroup.List( {
        @ConvertGroup(from=Default.class, to=BasicPostal.class),
        @ConvertGroup(from=Complete.class, to=FullPostal.class)
    } )
    Set&lt;Address&gt; getAddresses() { ... }
}</programlisting>
        </example>

        <para>When validating an instance of <classname>User</classname> with
        the <classname>Default</classname> group, the associated addresses are
        validated with the <classname>BasicPostal</classname> group. When
        validating an instance of <classname>User</classname> with the
        <classname>Complete</classname> group, the associated addresses are
        validated with the <classname>FullPostal</classname> group.</para>

        <para>The following example shows an illegal declaration of a group
        conversion rule on a method's return value:</para>

        <para><example>
            <title>Example of an illegal group conversion</title>

            <programlisting language="JAVA" role="JAVA">public interface BasicPostal {}

public class Order { ... }

public interface RetailOrderService {

    @Valid
    Order placeOrder(String itemNo, int quantity);
}

public interface B2BOrderService {

    @Valid
    @ConvertGroup(from=Default.class, to=BasicPostal.class)
    Order placeOrder(String itemNo, int quantity);
}

public class OrderService implements RetailOrderService, B2BOrderService {

    @Override
    public Order placeOrder(String itemNo, int quantity) {
        ...
    }
}</programlisting>
          </example>Here the class <classname>OrderService</classname>
        implements the two unrelated interfaces
        <classname>RetailOrderService</classname> and
        <classname>B2BOrderService</classname>, which both define a method
        <methodname>placeOrder()</methodname>, marking the return value as
        cascaded.</para>

        <para>The group conversion declared in
        <classname>B2BOrderService</classname> is illegal as per the rules
        defined in the previous section, since the set of applied validation
        groups might be altered unexpectedly for a client of the
        <classname>RetailOrderService</classname> interface.</para>
      </section>
    </section>

    <section id="constraintdeclarationvalidationprocess-groupsequence-formaldefinition">
      <title>Formal group definitions</title>

      <para>The formal rules defining groups are as followed. <emphasis>Text
      in italic are comments about the rules.</emphasis></para>

      <para>For every class <classname>X</classname>:</para>

      <orderedlist numeration="upperalpha">
        <listitem>
          <para>For each superclass <classname>Y</classname> of
          <classname>X</classname>, the group <classname>Y</classname>
          contains all constraints of the group <classname>Y</classname> of
          <classname>Y</classname></para>

          <para><emphasis>this rule prepares formal concepts for recursive
          discovery</emphasis></para>
        </listitem>

        <listitem>
          <para>The group <classname>X</classname> contains the following
          constraints:</para>

          <para><emphasis>group <classname>X</classname> is a group used on
          sequences redefining the default group on a class (see <xref
          linkend="constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup"/>)</emphasis></para>

          <orderedlist>
            <listitem>
              <para>every constraint declared by the class
              <classname>X</classname> which does not declare a group or does
              declare the group <classname>Default</classname>
              explicitly.</para>

              <para><emphasis>all <classname>Default</classname> constraints
              hosted on <classname>X</classname></emphasis></para>
            </listitem>

            <listitem>
              <para>every constraint declared by any interface implemented by
              <classname>X</classname> and not annotated
              <classname>@GroupSequence</classname> which does not explicitly
              declare a group or does declare the group
              <classname>Default</classname> explicitly.</para>

              <para><emphasis>all <classname>Default</classname> constraints
              hosted on interfaces of <classname>X</classname>: constraints
              are inherited by the class hierarchy. Interfaces marked as
              <classname>@GroupSequence</classname> are
              ignored.</emphasis></para>
            </listitem>

            <listitem>
              <para>if <classname>X</classname> has a direct superclass
              <classname>Y</classname>, every constraint in the group
              <classname>Y</classname></para>

              <para><emphasis>all <classname>Default</classname> constraints
              hosted on the superclasses of <classname>X</classname>:
              constraints are inherited by the class
              hierarchy</emphasis></para>
            </listitem>
          </orderedlist>
        </listitem>

        <listitem role="tck-testable">
          <para>If <classname>X</classname> has no
          <classname>@GroupSequence</classname> annotation, the group
          <classname>Default</classname> contains the following
          constraints:</para>

          <para role="tck-ignore"><emphasis>this rule defines which
          constraints are evaluated when validating
          <classname>Default</classname> on
          <classname>X</classname>.</emphasis></para>

          <orderedlist>
            <listitem>
              <para>every constraint in the group
              <classname>X</classname></para>
            </listitem>

            <listitem>
              <para>if <classname>X</classname> has a direct superclass
              <classname>Y</classname>, every constraint in the group
              <classname>Default</classname> of
              <classname>Y</classname></para>

              <para role="tck-ignore"><emphasis>this rule is necessary in case
              <classname>Y</classname> redefines the group
              <classname>Default</classname></emphasis></para>
            </listitem>
          </orderedlist>
        </listitem>

        <listitem>
          <para role="tck-testable">If <classname>X</classname> does have a
          <classname>@GroupSequence</classname> annotation, the group
          <classname>Default</classname> contains every constraint belonging
          to every group declared by the <classname>@GroupSequence</classname>
          annotation.</para>

          <para><emphasis>this rule describes how a class can redefine the
          group <classname>Default</classname> for itself (see <xref
          linkend="constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup"/>)</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>the <classname>@GroupSequence</classname> annotation must
              declare the group <classname>X</classname></para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>For every interface <classname>Z</classname>, the group
          <classname>Z</classname> contains the following constraints:</para>

          <para><emphasis>this rule defines how non
          <classname>Default</classname> groups are defined</emphasis></para>

          <orderedlist>
            <listitem>
              <para>every constraint declared by the interface
              <classname>Z</classname> which does not explicitly declare a
              group or does declare the group <classname>Default</classname>
              explicitly.</para>

              <para><emphasis>all <classname>Default</classname> constraints
              hosted on <classname>Z</classname>: this rule formally defines
              implicit grouping per interface (see <xref
              linkend="constraintdeclarationvalidationprocess-groupsequence-implicitgrouping"/>)</emphasis></para>
            </listitem>

            <listitem>
              <para>every constraint (which does not explicitly declare a
              group) declared by any superinterface not annotated
              <classname>@GroupSequence</classname> of the interface
              <classname>Z</classname></para>

              <para><emphasis>all <classname>Default</classname> constraints
              hosted on interfaces of <classname>Z</classname>: groups can be
              inherited (see <xref
              linkend="constraintdeclarationvalidationprocess-groupsequence-groupinheritance"/>)</emphasis></para>
            </listitem>

            <listitem>
              <para>every constraint declared by the class
              <classname>X</classname> which explicitly declares the group
              <classname>Z</classname></para>

              <para><emphasis>every constraint hosted by
              <classname>X</classname> and marked as belonging to the group
              <classname>Z</classname></emphasis></para>
            </listitem>

            <listitem>
              <para>every constraint declared by any interface implemented by
              <classname>X</classname> and not annotated
              <classname>@GroupSequence</classname> which explicitly declares
              the group <classname>Z</classname></para>

              <para><emphasis>every constraint hosted by any interface of
              <classname>X</classname> and marked as belonging to the group
              <classname>Z</classname></emphasis></para>
            </listitem>

            <listitem>
              <para>if <classname>X</classname> has a direct superclass
              <classname>Y</classname>, every constraint in the group
              <classname>Z</classname> of <classname>Y</classname></para>

              <para><emphasis>every constraint hosted by any superclass of
              <classname>X</classname> and marked as belonging to the group
              <classname>Z</classname></emphasis></para>
            </listitem>
          </orderedlist>
        </listitem>

        <listitem>
          <para>For every interface <classname>Z</classname> annotated
          <classname>@GroupSequence</classname>, the group
          <classname>Z</classname> contains every constraint belonging to
          every group declared by the <classname>@GroupSequence</classname>
          annotation.</para>

          <para><emphasis>defines the composition side of group sequence but
          does not define the ordering behavior of sequence (see <xref
          linkend="constraintdeclarationvalidationprocess-groupsequence-groupsequence"/>)</emphasis></para>
        </listitem>
      </orderedlist>

      <para>When a given group <classname>G</classname> (represented by an
      interface <classname>G</classname>) is requested for the validation of a
      class <classname>X</classname>:</para>

      <itemizedlist>
        <listitem>
          <para>constraints belonging to the group <classname>G</classname>
          are evaluated</para>
        </listitem>

        <listitem>
          <para>if the interface <classname>G</classname> is not annotated
          <classname>@GroupSequence</classname>, every group represented by
          the super interface of <classname>G</classname> are requested for
          validation</para>
        </listitem>

        <listitem>
          <para>if the interface <classname>G</classname> is annotated with
          <classname>@GroupSequence</classname>, every group represented by
          the interfaces declared by the <classname>@GroupSequence</classname>
          annotation are requested for validation</para>

          <itemizedlist>
            <listitem>
              <para>the validation of groups declared to the
              <classname>@GroupSequence</classname> must happen in the
              sequencing order declared by
              <classname>@GroupSequence</classname>: the sequencing order is
              propagated to the groups composing the sequenced group (via
              inheritance or group sequence)</para>
            </listitem>

            <listitem>
              <para>if a group validation triggers the failure of one or more
              constraints, groups following in the sequence must not be
              evaluated.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>if the group <classname>G</classname> represents the
          <classname>Default</classname> group of <classname>X</classname>
          overridden by <classname>@GroupSequence</classname>, operations are
          equivalent</para>
        </listitem>
      </itemizedlist>

      <para>When the <classname>Default</classname> group of a given class
      <classname>X</classname> is overridden via
      <classname>@GroupSequence</classname>, its validation is as
      followed:</para>

      <itemizedlist>
        <listitem>
          <para>every group represented by the interfaces declared by the
          <classname>@GroupSequence</classname> annotation are requested for
          validation</para>

          <itemizedlist>
            <listitem>
              <para>the validation of groups declared to the
              <classname>@GroupSequence</classname> must happen in the
              sequencing order declared by
              <classname>@GroupSequence</classname>: the sequencing order is
              propagated to the groups composing the sequenced group (via
              inheritance or group sequence)</para>
            </listitem>

            <listitem>
              <para>if a group validation triggers the failure of one or more
              constraints, groups following in the sequence must not be
              evaluated.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Unless defined by a <classname>@GroupSequence</classname>,
      evaluation ordering is not constrained. In particular, several groups
      can be validated in the same pass. If a group definition leads to a
      circular sequencing order between groups, a
      <classname>GroupDefinitionException</classname> is raised.</para>

      <note>
        <para>A group <classname>G</classname> sequenced (directly or
        indirectly) to be executed before itself is not considered a circular
        reference.</para>
      </note>
    </section>
  </section>

  <section id="constraintdeclarationvalidationprocess-methodlevelconstraints"
           revisionflag="added">
    <title>Method and constructor constraints</title>

    <note>
      <para>In the following, the term "method constraint" refers to
      constraints declared on methods as well as constructors.</para>
    </note>

    <para>Method constraints are declared by adding constraint annotations
    directly to methods or constructors and/or their parameters. In the former
    case, all the parameters of an executable (cross-parameter constraint) or
    the return value is constrained, in the latter individual parameters are
    constrained. As with bean constraints, this can be done using either
    actual Java annotations or using an XML constraint mapping file (see <xref
    linkend="xml-mapping-constraintdeclarationinxml-methodleveloverriding"/>).
    Bean Validation providers are free to provide additional means of defining
    method constraints such as an API-based approach.</para>

    <para>Getters are not considered constrained methods by default (see <xref
    linkend="integration-general-executable"/>).</para>

    <section>
      <title>Requirements on methods to be validated</title>

      <para><phrase role="tck-not-testable tck-needs-update">Static methods
      are ignored by validation. Putting constraints on a static method is not
      portable.</phrase> No other restrictions exist from the perspective of
      this specification, however it is possible that technologies integrating
      with method validation impose further restrictions to methods for which
      a validation shall be applied. For instance certain integration
      technologies might require that methods to be validated must have
      <methodname>public</methodname> visibility and/or must not be
      final.</para>
    </section>

    <section>
      <title>Declaring parameter constraints</title>

      <para role="tck-testable">Parameter constraints are declared by putting
      constraint annotations on method or constructor parameters.</para>

      <example>
        <title>Declaring parameter constraints</title>

        <programlisting>public class OrderService {

    public OrderService(@NotNull CreditCardProcessor creditCardProcessor) {
        [...]
    }

    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {

        [...]
    }
}</programlisting>
      </example>

      <para>Using constraint annotations, several preconditions are defined
      here. These preconditions which must be satisfied in order to legally
      invoke the methods of <classname>OrderService</classname> are:</para>

      <itemizedlist>
        <listitem>
          <para>The <classname>CreditCardProcessor</classname> passed to the
          constructor must not be null.</para>
        </listitem>

        <listitem>
          <para>The customer code passed to the
          <methodname>placeOrder()</methodname> method must not be null and
          must be between 3 and 20 characters long.</para>
        </listitem>

        <listitem>
          <para>The <classname>Item</classname> passed to the
          <methodname>placeOrder()</methodname> method must not be
          null.</para>
        </listitem>

        <listitem>
          <para>The quantity value passed to the
          <methodname>placeOrder()</methodname> method must be 1 at
          least.</para>
        </listitem>
      </itemizedlist>

      <para>Note that declaring these constraints does not automatically cause
      their validation when the concerned methods are invoked. It's the
      responsibility of an integration layer to trigger the validation of the
      constraints using a method interceptor, dynamic proxy or similar. See
      section <xref linkend="validationapi-triggeringmethodvalidation"/> for
      more details.</para>

      <tip>
        <para>In order to use constraint annotations for method or constructor
        parameters, their element type must be
        <varname>ElementType.PARAMETER</varname>. In order to use constraint
        annotations for cross-parameter validation or on the return values of
        methods or constructors (see the following sections), their element
        type must be <varname>ElementType.METHOD</varname> respectively
        <varname>ElementType.CONSTRUCTOR</varname>. All built-in constraints
        support these element types and it is considered a best practice to do
        the same for custom constraints.</para>
      </tip>

      <section id="constraintdeclarationvalidationprocess-crossparameterconstraints">
        <title>Cross-parameter constraints</title>

        <para>Cross-parameter constraints allow to express constraints based
        on the value of several method parameters, similar to class-level
        constraints which are based on several properties of a given class.
        <phrase role="tck-testable">Cross-parameter constraints are declared
        by putting cross-parameter constraint annotations on methods or
        constructors</phrase> as shown in the following example.</para>

        <example>
          <title>Declaring cross-parameter constraints</title>

          <programlisting language="JAVA">public class CalendarService {

    @ConsistentDateParameters
    public void createEvent(
        String title,
        @NotNull Date startDate,
        @NotNull Date endDate) {
        //...
    }
}</programlisting>
        </example>

        <para>The cross-parameter constraint annotation expresses here that
        the given start date must be before the passed end date in order to
        legally invoke the <methodname>createEvent()</methodname> method. The
        example also shows that it is often useful to combine constraints
        directly placed on individual parameters (<classname>e.g.
        @NotNull</classname>) and cross-parameter constraints.</para>

        <para><tip>
            <para>Cross-parameter constraints as well as return value
            constraints are declared directly on a method or a constructor. To
            make it obvious for a reader that an annotation refers to the
            parameters of a method or constructor and not its return value, it
            is recommended to chose a name which clearly expresses this
            intention.</para>
          </tip></para>

        <para role="tck-testable">Cross parameters constraints are validated
        at the same time as parameter constraints.</para>
      </section>

      <section id="constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters">
        <title>Naming parameters</title>

        <para>In case the validation of a parameter constraint fails, the
        concerned parameter needs to be identified in the resulting
        <classname>ConstraintViolation</classname> (see section <xref
        linkend="validationapi-constraintviolation"/>). As of version 7, Java
        doesn't provide a portable way to retrieve parameter names. Bean
        Validation therefore defines the
        <classname>javax.validation.ParameterNameProvider</classname> API to
        which the retrieval of parameter names is delegated:</para>

        <programlisting language="JAVA" role="JAVA">/**
 * Provides names for method and constructor parameters.
 * &lt;p/&gt;
 * Used by the Bean Validation runtime when creating constraint violation
 * objects for violated method constraints.
 * &lt;p/&gt;
 * Implementations must be thread-safe.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface ParameterNameProvider {

    /**
     * Returns the names of the parameters of the given constructor.
     *
     * @param constructor The constructor for which the parameter names shall be
     *        retrieved. Never null.
     *
     * @return A list containing the names of the parameters of the given
     *         constructor. May be empty but never null.
     */
    List&lt;String&gt; getParameterNames(Constructor&lt;?&gt; constructor);

    /**
     * Returns the names of the parameters of the given method.
     *
     * @param method The method for which the parameter names shall be retrieved.
     *        Never null.
     *
     * @return A list containing the names of the parameters of the given method.
     *         May be empty but never null.
     */
    List&lt;String&gt; getParameterNames(Method method);
}</programlisting>

        <para role="tck-testable">A conforming Bean Validation implementation
        provides a default <classname>ParameterNameProvider</classname>
        implementation which returns parameter names in the form
        <varname>arg</varname><emphasis>PARAMETER_INDEX</emphasis>, where
        <emphasis>PARAMETER_INDEX</emphasis> starts at 0 for the first
        parameter, e.g. <varname>arg0</varname>, <varname>arg1</varname>
        etc.</para>

        <para>Bean Validation providers and integrators are free to provide
        additional implementations (e.g. based on annotations specifying
        parameter names, debug symbols etc.). If a user wishes to use another
        parameter name provider than the default implementation, she may
        specify the provider to use with help of the bootstrap API (see <xref
        linkend="bootstrapping"/>) or the XML configuration (see <xref
        linkend="xml-config"/>).</para>

        <para role="tck-testable">If an exception occurs during invocation of
        the <methodname>getParameterNames()</methodname> methods, this
        exception is wrapped into a <classname>ValidationException</classname>
        by the Bean Validation engine.</para>
      </section>
    </section>

    <section>
      <title>Declaring return value constraints</title>

      <para role="tck-testable">Return value constraints are declared by
      putting constraint annotations directly on a method or
      constructor.</para>

      <example>
        <title>Declaring return value constraints</title>

        <programlisting language="JAVA" role="JAVA">public class OrderService {

    private CreditCardProcessor creditCardProcessor;

    @ValidOnlineOrderService
    public OrderService(OnlineCreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @ValidBatchOrderService
    public OrderService(BatchCreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @NotNull
    @Size(min=1)
    public Set&lt;CreditCardProcessor&gt; getCreditCardProcessors() { ... }

    @NotNull
    @Future
    public Date getNextAvailableDeliveryDate() { ... }
}</programlisting>
      </example>

      <para>Here the following postconditions are defined which are guaranteed
      to the caller of the methods and constructors of the
      <classname>OrderService</classname> class:</para>

      <itemizedlist>
        <listitem>
          <para>The newly created <classname>OrderService</classname> object
          returned by the first constructor satisfies the conditions of the
          custom <classname>@ValidOnlineOrderService</classname>
          constraint.</para>
        </listitem>

        <listitem>
          <para>The newly created <classname>OrderService</classname> object
          returned by the second constructor satisfies the conditions of the
          custom <classname>@ValidBatchOrderService</classname>
          constraint.</para>
        </listitem>

        <listitem>
          <para>The set of <classname>CreditCardProcessor</classname> objects
          returned by <methodname>getCreditCardProcessors()</methodname> will
          neither be null nor be empty.</para>
        </listitem>

        <listitem>
          <para>The <classname>Date</classname> object returned by
          <methodname>getNextAvailableDeliveryDate()</methodname> will not be
          null and will be in the future.</para>
        </listitem>
      </itemizedlist>

      <para>Like parameter constraints, these return value constraints are not
      per-se validated upon method invocation, but instead an integration
      layer invoking the validation is required.</para>
    </section>

    <section>
      <title>Marking parameters and return values for cascaded
      validation</title>

      <para><phrase role="tck-testable">The <classname>@Valid</classname>
      annotation is used to declare that a cascaded validation of the given
      method/constructor parameters or return values is performed by the Bean
      Validation provider. When marked, the parameter or return value is
      considered a bean object to validate.</phrase> The same rules as for
      standard object graph validation (see <xref
      linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"/>)
      apply, in particular</para>

      <itemizedlist>
        <listitem>
          <para role="tck-testable">null arguments and null return values are
          ignored</para>
        </listitem>

        <listitem>
          <para role="tck-testable">The validation is recursive; that is, if
          validated parameter or return value objects have references marked
          with <classname>@Valid</classname> themselves, these references will
          also be validated</para>
        </listitem>

        <listitem>
          <para>Bean Validation providers must guarantee the prevention of
          infinite loops during cascaded validation</para>
        </listitem>
      </itemizedlist>

      <example>
        <title>Marking parameters and return values for cascaded
        validation</title>

        <programlisting language="JAVA" role="JAVA">public class OrderService {

    @NotNull @Valid
    private CreditCardProcessor creditCardProcessor;

    @Valid
    public OrderService(@NotNull @Valid CreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @NotNull @Valid
    public Order getOrderByPk(@NotNull @Valid OrderPK orderPk) { ... }

    @NotNull @Valid
    public Set&lt;Order&gt; getOrdersByCustomer(@NotNull @Valid CustomerPK customerPk) { ... }
}</programlisting>
      </example>

      <para>Here the following recursive validations will happen when
      validating the methods of the <classname>OrderService</classname>
      class:</para>

      <itemizedlist>
        <listitem>
          <para>Validation of the constraints on the object passed for the
          <varname>creditCardProcessor</varname> parameter of the
          constructor</para>
        </listitem>

        <listitem>
          <para>Validation of the constraints on the newly created
          <classname>OrderService</classname> instance returned by the
          constructor, i.e. the <classname>@NotNull</classname> constraint on
          the field <varname>creditCardProcessor</varname> and the constraints
          on the referenced <classname>CreditCardProcessor</classname>
          instance (as the field is annotated with
          <classname>@Valid</classname>).</para>
        </listitem>

        <listitem>
          <para>Validation of the constraints on the object passed for the
          <varname>orderPk</varname> parameter and the returned
          <classname>Order</classname> object of the
          <methodname>getOrderByPk()</methodname> method</para>
        </listitem>

        <listitem>
          <para>Validation of the constraints on the object passed for the
          <varname>customerPk</varname> parameter and the constraints on each
          object contained within the returned
          <varname>Set&lt;Order&gt;</varname> of the
          <methodname>getOrdersByCustomer()</methodname> method</para>
        </listitem>
      </itemizedlist>

      <para>Again, solely marking parameters and return values for cascaded
      validation does not trigger the actual validation.</para>
    </section>

    <section id="constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance">
      <title>Method constraints in inheritance hierarchies</title>

      <para>When defining method constraints within inheritance hierarchies
      (that is, class inheritance by extending base classes and interface
      inheritance by implementing or extending interfaces) one has to obey the
      <ulink
      url="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov
      substitution</ulink> principle which mandates that:</para>

      <itemizedlist>
        <listitem>
          <para>a method's preconditions (as represented by parameter
          constraints) may not be strengthened in sub types</para>
        </listitem>

        <listitem>
          <para>a method's postconditions (as represented by return value
          constraints) may not be weakened in sub types</para>
        </listitem>
      </itemizedlist>

      <tip>
        <para>Very informally speaking, the Liskov substitution principle says
        that where a given type T is used, it should be possible to replace T
        with a sub-type S of T ("Behavioral subtyping"). If S
        overrides/implements a method from T and S would strengthen the
        method's preconditions (e.g. by adding parameter constraints) this
        principle would be violated as client code working correctly against T
        might fail when working against S. Also if S overrides/implements a
        method from T and S weakens the method's postconditions this principle
        would be violated. However S may strengthen the method's
        postconditions (by adding return value constraints), as client code
        working against T still will work against S.</para>
      </tip>

      <para>Therefore the following rules with respect to the definition of
      method level constraints in inheritance hierarchies apply:</para>

      <itemizedlist>
        <listitem>
          <para role="tck-testable">In sub types (be it sub classes/interfaces
          or interface implementations), no parameter constraints may be
          declared on overridden or implemented methods, nor may parameters be
          marked for cascaded validation. This would pose a strengthening of
          preconditions to be fulfilled by the caller.</para>
        </listitem>

        <listitem>
          <para role="tck-testable">If a sub type overrides/implements a
          method originally defined in several parallel types of the hierarchy
          (e.g. two interfaces not extending each other, or a class and an
          interface not implemented by said class), no parameter constraints
          may be declared for that method at all nor parameters be marked for
          cascaded validation. This again is to avoid an unexpected
          strengthening of preconditions to be fulfilled by the caller.</para>
        </listitem>

        <listitem>
          <para role="tck-testable">In sub types (be it sub classes/interfaces
          or interface implementations), return value constraints may be
          declared on overridden or implemented methods and the return value
          may be marked for cascaded validation. Upon validation, all return
          value constraints of the method in question are validated, wherever
          they are declared in the hierarchy. This only poses possibly a
          strengthening but no weakening of the method's postconditions
          guaranteed to the caller.</para>
        </listitem>

        <listitem>
          <para role="tck-testable">One must not mark a method return value
          for cascaded validation more than once in a line of a class
          hierarchy. In other words, overriding methods on sub types (be it
          sub classes/interfaces or interface implementations) cannot mark the
          return value for cascaded validation if the return value has already
          been marked on the overridden method of the super type or
          interface.</para>
        </listitem>
      </itemizedlist>

      <para>Out of the box, a conforming Bean Validation provider must throw a
      <classname>ConstraintDeclarationException</classname> when discovering
      that any of these rules are violated. In addition providers may
      implement alternative, potentially more liberal, approaches for handling
      constrained methods in inheritance hierarchies. Possible means for
      activating such alternative behavior include provider-specific
      configuration properties or annotations. Note that client code relying
      on such alternative behavior is not portable between Bean Validation
      providers.</para>

      <para role="tck-testable">The above rules do not apply when validating
      constructor constraints as constructors do not override one another.
      Parameter and return value constraints can be applied to any constructor
      in the type hierarchy, but only the constraints defined directly on the
      validated constructor are evaluated.</para>

      <section>
        <title>Examples</title>

        <para>This sections provides some examples of illegal constraint
        definitions which violate the rules stated above in one way or
        another.</para>

        <example>
          <title>Illegally declared parameter constraints on interface
          implementation</title>

          <programlisting language="JAVA" role="JAVA">public interface OrderService {

    void placeOrder(String customerCode, Item item, int quantity);
}

public class SimpleOrderService implements OrderService {

    @Override
    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {
        [...]
    }
}</programlisting>
        </example>

        <para>The constraints in <classname>SimpleOrderService</classname> are
        illegal, as they strengthen the preconditions of the
        <methodname>placeOrder()</methodname> method as constituted by the
        interface <classname>OrderService</classname>.</para>

        <para><example>
            <title>Illegally declared parameter constraints on sub
            class</title>

            <programlisting language="JAVA" role="JAVA">public class OrderService {

    void placeOrder(String customerCode, Item item, int quantity) { ... }
}

public class SimpleOrderService extends OrderService {

    @Override
    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {
        [...]
    }
}</programlisting>
          </example></para>

        <para>The constraints in <classname>SimpleOrderService</classname> are
        illegal, as they strengthen the preconditions of the
        <methodname>placeOrder()</methodname> method as constituted by the
        super class <classname>OrderService</classname>.</para>

        <para><example id="illegal_constraints_in_parallel_types">
            <title>Illegally declared parameter constraints on parallel
            types</title>

            <programlisting language="JAVA" role="JAVA">public interface OrderService {

    void placeOrder(String customerCode, Item item, int quantity);
}

public interface OrderPlacementService {

    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity);
}

public class SimpleOrderService implements OrderService, OrderPlacementService {

    @Override
    public void placeOrder(String customerCode, Item item, int quantity) {
        [...]
    }
}</programlisting>
          </example>Here the class <classname>SimpleOrderService</classname>
        implements the interfaces <classname>OrderService</classname> and
        <classname>OrderPlacementService</classname>, which themselves are
        unrelated to each other but both define a method
        <methodname>placeOrder()</methodname> with an identical signature.
        This hierarchy is illegal with respect to the parameter constraints as
        a client of <classname>SimpleOrderService</classname> would have to
        fulfill the constraints defined on the interface
        <classname>OrderPlacementService</classname> even if the client only
        expects <classname>OrderService</classname>.</para>

        <para><example>
            <title>Correctly declared return value constraints on sub
            class</title>

            <programlisting language="JAVA" role="JAVA">public class OrderService {

    Order placeOrder(String customerCode, Item item, int quantity) {
        [...]
    }
}

public class SimpleOrderService extends OrderService {

    @Override
    @NotNull
    @Valid
    public Order placeOrder(String customerCode, Item item, int quantity) {
        [...]
    }
}</programlisting>
          </example>The return value constraints in
        <classname>DefaultOrderService</classname> are legal, as they
        strengthen the postconditions of the
        <methodname>placeOrder()</methodname> method as constituted by the
        super class <classname>OrderService</classname> but don't weaken
        them.</para>
      </section>
    </section>
  </section>

  <section id="constraintdeclarationvalidationprocess-validationroutine">
    <title>Validation routine</title>

    <para role="tck-not-testable">For a given group, the validation routine
    applied on a given bean instance is expected to execute the following
    constraint validations in no particular order:</para>

    <itemizedlist>
      <listitem>
        <para>for all <emphasis>reachable</emphasis> fields, execute all field
        level validations (including the ones expressed on superclasses)
        matching the targeted group unless the given validation constraint has
        already been processed during this validation routine for a given
        navigation path (see <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"/>)
        as part of a previous group match.</para>
      </listitem>

      <listitem>
        <para>for all <emphasis>reachable</emphasis> getters, execute all
        getter level validations (including the ones expressed on interfaces
        and superclasses) matching the targeted group unless the given
        validation constraint has already been processed during this
        validation routine for a given navigation path (see <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"/>)
        as part of a previous group match.</para>
      </listitem>

      <listitem>
        <para>execute all class level validations (including the ones
        expressed on interfaces and superclasses) matching the targeted group
        unless the given validation constraint has already been processed
        during this validation routine for a given navigation path (see <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"/>)
        as part of a previous group match.</para>
      </listitem>

      <listitem>
        <para>for all <emphasis>reachable</emphasis> and
        <emphasis>cascadable</emphasis> associations, execute all cascading
        validations (see <xref
        linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"/>)
        including the ones expressed on interfaces and superclasses (see <xref
        linkend="constraintdeclarationvalidationprocess-groupsequence-formaldefinition"/>).
        <phrase revisionflag="added">Note that group conversion can apply (see
        <xref
        linkend="constraintdeclarationvalidationprocess-groupsequence-groupconversion"/>).</phrase></para>
      </listitem>
    </itemizedlist>

    <para>Reachable fields, getters and associations as well as cascadable
    associations are defined in <xref
    linkend="constraintdeclarationvalidationprocess-validationroutine-traversable"/>.</para>

    <para>Note that this implies that a given validation constraint will not
    be processed more than once per validation per path. Some implementations
    might even process a single constraint only once across paths provided
    that they return the expected set of
    <classname>ConstraintViolation</classname>.</para>

    <para><phrase role="tck-not-testable">Unless ordered by group sequences,
    groups can be validated in no particular order.</phrase> This implies that
    the validation routine can be run for several groups in the same
    pass.</para>

    <para>The object validation routine is described as such. For each
    constraint declaration:</para>

    <itemizedlist>
      <listitem>
        <para>determine for the constraint declaration, the appropriate
        <classname>ConstraintValidator</classname> to use (see <xref
        linkend="typevalidatorresolution"/>).</para>
      </listitem>

      <listitem>
        <para>execute the <methodname>isValid</methodname> operation (from the
        constraint validation implementation) on the appropriate data (see
        <xref
        linkend="constraintsdefinitionimplementation-validationimplementation"/>)</para>
      </listitem>

      <listitem>
        <para>if <methodname>isValid</methodname> returns
        <literal>true</literal>, continue to the next constraint,</para>
      </listitem>

      <listitem>
        <para>if <methodname>isValid</methodname> returns
        <literal>false</literal>, the Bean Validation provider populates
        <classname>ConstraintViolation</classname> object(s) according to the
        rules defined in <xref
        linkend="constraintsdefinitionimplementation-validationimplementation"/>
        and appends these objects to the list of constraint violations.</para>
      </listitem>
    </itemizedlist>

    <section id="constraintdeclarationvalidationprocess-validationroutine-graphvalidation">
      <title>Object graph validation</title>

      <para><phrase role="tck-testable">The <classname>@Valid</classname>
      annotation on a given association (i.e. object reference or collection,
      array, <classname>Iterable</classname> of objects), dictates the Bean
      Validator implementation to apply recursively the Bean Validation
      routine on (each of) the associated object(s).</phrase> <phrase
      role="tck-testable">This mechanism is recursive: an associated object
      can itself contain cascaded references.</phrase></para>

      <para role="tck-testable">Null references are ignored.</para>

      <para><phrase role="tck-testable">To prevent infinite loops, the Bean
      Validation implementation must ignore the cascading operation if the
      associated object instance has already been validated in the current
      navigation path (starting from the root object).</phrase> See <xref
      linkend="example-oglimit"/> for an example. A navigation path is defined
      as a set of <classname>@Valid</classname> associations starting from the
      root object instance and reaching the associated instance. A given
      navigation path cannot contain the same instance multiple times (the
      complete validated object graph can though). See <xref
      linkend="example-oglimit"/> for an example.</para>

      <note>
        <para>This object graph navigation can lead to multiple validations of
        the same constraint and the same object instance but the set of
        constraint validation is deterministic and the algorithm prevents
        infinite loops.</para>
      </note>

      <example id="example-oglimit">
        <title>Object graph limits</title>

        <programlisting>#assuming the following object graph

Order -(lines)-&gt; Orderline1
Order -(lines)-&gt; Orderline2
Orderline1 -(order)-&gt; Order
Orderline2 -(order)-&gt; Order
Order -(customer)-&gt; User
Order -(shippingAddress)-&gt; Address1
Order -(billingAddress)-&gt; Address2
Address1 -(inhabitant)-&gt; User
Address2 -(inhabitant)-&gt; User
User -(addresses)-&gt; Address1
User -(addresses)-&gt; Address2

#validation branches are as followed
Order -(lines)-&gt; Orderline1
  - order is ignored: Order is already present in the branch 

Order -(lines)-&gt; Orderline2
  - order is ignored: Order is already present in the branch

Order -(customer)-&gt; User -(addresses)-&gt; Address1
  - inhabitant is ignored: User is already present in the branch

Order -(customer)-&gt; User -(addresses)-&gt; Address2
  - inhabitant is ignored: User is already present in the branch

Order -(shippingAddress)-&gt; Address1 -(inhabitant)-&gt; User 
  - addresses to Address1 is ignored: Address1 is already present in the branch

Order -(shippingAddress)-&gt; Address1 -(inhabitant)-&gt; User -(addresses)-&gt; Address2
  - inhabitant is ignored: User is already present in the branch

Order -(billingAddress)-&gt; Address2 -(inhabitant)-&gt; User 
  - addresses to Address2 is ignored: Address2 is already present in the branch

Order -(billingAddress)-&gt; Address2 -(inhabitant)-&gt; User -(addresses)-&gt; Address1
  - inhabitant is ignored: User is already present in the branch</programlisting>
      </example>

      <para>The <classname>ConstraintViolation</classname> objects are built
      when a failing constraint on an associated object is found. They reflect
      the path to reach the object from the root validated object (See <xref
      linkend="validationapi-constraintviolation"/>).</para>

      <para><phrase role="tck-testable"><classname>@Valid</classname> is an
      orthogonal concept to the notion of group. If two groups are in
      sequence, the first group must pass for all associated objects before
      the second group is evaluated.</phrase> Note however that the
      <classname>Default</classname> group sequence overriding is local to the
      class it is defined on and is not propagated to the associated objects.
      The following example illustrates this:</para>

      <para><example>
          <title>Class Driver with redefined default group</title>

          <programlisting>@GroupSequence({ Minimal.class, Driver.class })
public class Driver {
  @Min(value = 18, groups = Minimal.class)
  int age;

  @AssertTrue
  Boolean passedDrivingTest;

  @Valid
  Car car;

  // setter/getters
}</programlisting>
        </example><example>
          <title>Class Car with redefined default group</title>

          <programlisting>@GroupSequence({ Car.class, Later.class })
public class Car {
  @NotNull
  String type;

  @AssertTruegroups = Later.class)
  Boolean roadWorthy;

  // setter/getters
}</programlisting>
        </example><example>
          <title>Defining a group sequence</title>

          <programlisting>@GroupSequence({ Minimal.class, Later.class })
public interface SequencedGroups {
}</programlisting>
        </example><example>
          <title>Group sequence overriding is not propagated to associated
          objects</title>

          <programlisting>Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Driver driver = new Driver();
driver.setAge(16);
Car porsche = new Car();
driver.setCar(porsche);


Set&lt;ConstraintViolation&lt;Driver&gt;&gt; violations = validator.validate( driver );

assert violations.size() == 2;

violations = validator.validate( driver, SequencedGroups.class );

assert violations.size() == 1;</programlisting>
        </example>The default group sequence is redefined for the
      <classname>Driver</classname> as well as <classname>Car</classname>.
      When the default group is requested via <methodname>validator.validate(
      driver )</methodname> the group <classname>Minimal</classname> gets
      validated in class <classname>Driver</classname>. The constraint will
      fail since the driver's age in the example is only 16. The constraint on
      <property>passedDrivingTest</property> will not be evaluated due to the
      redefined default sequence of <classname>Driver</classname>. However,
      there is one more constraint violation, namely the
      <classname>@NotNull</classname> on <property>Car.type</property>. The
      reason for this is that the group <classname>Default</classname> gets
      propagated to <classname>Car</classname> (not
      <classname>Minimal</classname>). Class <classname>Driver</classname>
      defines its own group sequence which means that <classname>only
      @NotNull</classname> on <property>type</property> gets evaluated.</para>

      <para>In the second call to <methodname>validate</methodname> the group
      <classname>SequencedGroups</classname> is requested which defines a
      sequence of <classname>Minimal</classname> followed by
      <classname>Later</classname>. In this case there is only one constraint
      violation. Again <classname>@Min</classname> on <property>age</property>
      fails, but in this case the group <classname>Minimal</classname> gets
      propagated to <classname>Car</classname> which does not have any
      constraints defined against this group. Constraints belonging to the
      group <classname>Later</classname> won't get validated until all
      constraints belonging to <classname>Minimal</classname> pass.</para>
    </section>

    <section revisionflag="added">
      <title>Method and constructor validation</title>

      <para role="tck-testable">For a given group, the validation routine
      applied to validate parameters of a method or constructor is expected to
      execute the following constraint validations in no particular
      order:</para>

      <itemizedlist>
        <listitem>
          <para>execute all parameter validations (in case of overriding
          method validation, including the ones expressed on overridden
          methods of the interfaces and superclasses) matching the targeted
          group unless the given validation constraint has already been
          processed during this validation routine for a given navigation path
          (see <xref
          linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"/>)
          as part of a previous group match.</para>
        </listitem>

        <listitem>
          <para>execute all cross parameter validations (in case of overriding
          method validation, including the ones expressed on overridden
          methods of the interfaces and superclasses) matching the targeted
          group unless the given validation constraint has already been
          processed during this validation routine for a given navigation path
          (see <xref
          linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"/>)
          as part of a previous group match.</para>
        </listitem>

        <listitem>
          <para>for all parameters marked for cascaded validation, execute all
          cascading validations (see <xref
          linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"/>),
          in case of overriding method validation including the ones expressed
          on overridden methods of the interfaces and superclasses (see <xref
          linkend="constraintdeclarationvalidationprocess-groupsequence-formaldefinition"/>).
          Note that group conversion can apply (see <xref
          linkend="constraintdeclarationvalidationprocess-groupsequence-groupconversion"/>).</para>
        </listitem>
      </itemizedlist>

      <para role="tck-testable">For a given group, the validation routine
      applied to validate the return value of a method or constructor is
      expected to execute the following constraint validations in no
      particular order:</para>

      <itemizedlist>
        <listitem>
          <para>execute all return value validations (including the ones
          expressed on interfaces and superclasses) matching the targeted
          group unless the given validation constraint has already been
          processed during this validation routine for a given navigation path
          (see <xref
          linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"/>)
          as part of a previous group match.</para>
        </listitem>

        <listitem>
          <para>if the return value is marked for cascaded validation, execute
          all cascading validations (see <xref
          linkend="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"/>)
          including the ones expressed on interfaces and superclasses (see
          <xref
          linkend="constraintdeclarationvalidationprocess-groupsequence-formaldefinition"/>).
          Note that group conversion can apply (see <xref
          linkend="constraintdeclarationvalidationprocess-groupsequence-groupconversion"/>).</para>
        </listitem>
      </itemizedlist>

      <para>Note that this implies that a given validation constraint will not
      be processed more than once per validation per path. Some
      implementations might even process a single constraint only once across
      paths provided that they return the expected set of
      <classname>ConstraintViolation</classname>.</para>

      <para><phrase role="tck-testable">Unless ordered by group sequences,
      groups can be validated in no particular order.</phrase> This implies
      that the validation routine can be run for several groups in the same
      pass.</para>

      <para>The object validation routine is as defined in described in <xref
      linkend="constraintdeclarationvalidationprocess-validationroutine"/>.</para>
    </section>

    <section id="constraintdeclarationvalidationprocess-validationroutine-traversable">
      <title>Traversable property</title>

      <para>In some cases, the state of some properties should not be
      accessed. For example, if a property loaded by a Java Persistence
      provider is a lazy property or a lazy association, accessing its state
      would trigger a load from the database. An undesired behavior.</para>

      <para>Bean Validation offers a way to control which property can and
      cannot be accessed via the
      <classname>TraversableResolver.isReachable</classname>()
      contract.</para>

      <para>Likewise, it is sometimes undesirable to cascade validation
      despite the use of <classname>@Valid</classname>. Java Persistence 2 for
      example does not cascade to associated entities during flush. You can
      control this behavior by implementing
      <methodname>Traversable.isCascadable()</methodname>.</para>

      <programlisting>/**
 * Contract determining if a property can be accessed by the Bean Validation provider.
 * This contract is called for each property that is being either validated or cascaded.
 *
 * A traversable resolver implementation must be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface TraversableResolver {
    /**
     * Determine if the Bean Validation provider is allowed to reach the property state
     *
     * @param traversableObject object hosting {@code traversableProperty} or null
     *                          if {@code validateValue} is called
     * @param traversableProperty the traversable property.
     * @param rootBeanType type of the root object passed to the Validator.
     * @param pathToTraversableObject path from the root object to
     *        {@code traversableObject}
     *        (using the path specification defined by Bean Validator).
     * @param elementType either {@code FIELD} or {@code METHOD}.
     *
     * @return {@code true} if the Bean Validation provider is allowed to
     *         reach the property state, {@code false} otherwise.
     */
    boolean isReachable(Object traversableObject,
                        Path.Node traversableProperty,
                        Class&lt;?&gt; rootBeanType,
                        Path pathToTraversableObject,
                        ElementType elementType);

    /**
     * Determine if the Bean Validation provider is allowed to cascade validation on
     * the bean instance returned by the property value
     * marked as {@code @Valid}.
     * Note that this method is called only if {@code isReachable} returns true
     * for the same set of arguments and if the property is marked as {@code @Valid}
     *
     * @param traversableObject object hosting {@code traversableProperty} or null
     *                          if {@code validateValue} is called
     * @param traversableProperty the traversable property.
     * @param rootBeanType type of the root object passed to the Validator.
     * @param pathToTraversableObject path from the root object to
     *        {@code traversableObject}
     *        (using the path specification defined by Bean Validator).
     * @param elementType either {@code FIELD} or {@code METHOD}.
     *
     * @return {@code true} if the Bean Validation provider is allowed to
     *         cascade validation, {@code false} otherwise.
     */
    boolean isCascadable(Object traversableObject,
                         Path.Node traversableProperty,
                         Class&lt;?&gt; rootBeanType,
                         Path pathToTraversableObject,
                         ElementType elementType);
}</programlisting>

      <para><phrase role="tck-testable"><methodname>isReachable</methodname>
      is called for every property about to be accessed either for validation
      or for cascading.</phrase> A property is <emphasis>reachable</emphasis>
      if this method returns <literal>true</literal>.</para>

      <para><phrase role="tck-testable"><methodname>isCascadable</methodname>
      is called for every property about to be cascaded (i.e. marked as
      <classname>@Valid</classname>).</phrase> A property is
      <emphasis>cascadable</emphasis> if it is reachable and if the
      <methodname>isCascadable</methodname> method returns
      <literal>true</literal>.</para>

      <note>
        <para role="tck-testable"><methodname>isCascadable</methodname> for a
        given property is only called if <methodname>isReachable</methodname>
        returns <literal>true</literal>. In other words,
        <methodname>isReachable</methodname> is always called before
        <methodname>isCascadable</methodname> for a given property.</para>
      </note>

      <para><literal>traversableObject</literal> is the object instance being
      evaluated. <literal>null</literal> if the check is triggered as part of
      a <methodname>validateValue</methodname> call.</para>

      <para><literal>traversableProperty</literal> is the
      <classname>Node</classname> representing the property hosted by the
      <methodname>traversableObject</methodname> being considered for
      traversal. The name of a property is defined in <xref
      linkend="constraintdeclarationvalidationprocess-requirements-property"/>.</para>

      <para><literal>rootBeanType</literal> is the class of the root being
      validated, <phrase revisionflag="changed">i.e. either the type of the
      object passed to the <methodname>validate</methodname> method or the
      type declaring the validated method/constructor in case of method
      validation).</phrase></para>

      <para><literal>pathToTraversableObject</literal> is the
      <classname>Path</classname> from the
      <methodname>rootBeanType</methodname> down to the
      <methodname>traversableObject</methodname>. If the root object is
      <classname>traversableObject</classname>,
      <classname>pathToTraversableObject</classname> is composed of a single
      Node whose name is <literal>null</literal>. The path is described
      following the conventions described in <xref
      linkend="validationapi-constraintviolation"/>
      (<methodname>getPropertyPath</methodname>).</para>

      <para><literal>elementType</literal> is the
      <classname>java.lang.annotation.ElementType</classname> the annotation
      is placed on. It can be either <literal>FIELD</literal> or
      <literal>METHOD</literal>. Any other value is not expected.</para>

      <para role="tck-testable">The Bean Validation provider must not access
      the state of a property, nor validate its constraints if the property is
      not traversable. A property is traversable if
      <classname>TraversableResolver</classname> returns
      <literal>true</literal> for this property.</para>

      <para role="tck-testable">If an exception occurs when the
      <classname>TraversableResolver</classname> is called, the exception is
      wrapped into a <classname>ValidationException</classname>.</para>

      <para revisionflag="added" role="tck-testable">The following elements
      are not passed through the traversable resolver filter:<itemizedlist>
          <listitem>
            <para>the bean instance validated</para>
          </listitem>

          <listitem>
            <para>the method and constructor parameter values being
            validated</para>
          </listitem>

          <listitem>
            <para>the method and constructor return value being
            validated</para>
          </listitem>
        </itemizedlist></para>

      <para revisionflag="added" role="tck-testable">But the properties of
      these elements (if validated) are. In this case the complete path is
      provided via <literal>pathToTraversableObject</literal>.</para>

      <para>The traversable resolver used by default by a Bean Validation
      <phrase revisionflag="added">provider</phrase> behaves as
      followed:</para>

      <itemizedlist>
        <listitem>
          <para><phrase role="tck-not-testable">if Java Persistence is
          available in the runtime environment, a property is considered
          reachable if Java Persistence considers the property as
          loaded.</phrase> A typical implementation will use
          <code>Persistence.getPersistenceUtil().isLoaded(Object,
          String)</code> to implement such contract.</para>
        </listitem>

        <listitem>
          <para role="tck-not-testable">if Java Persistence is not available
          in the runtime environment, all properties are considered
          reachable.</para>
        </listitem>

        <listitem>
          <para role="tck-not-testable">all properties are considered
          cascadable.</para>
        </listitem>
      </itemizedlist>

      <para revisionflag="added">An examplary implementation of such a
      resolver is shown in <xref
      linkend="constraintdeclarationvalidationprocess-validationroutine-traversable-jparesolver"/>.</para>

      <example id="constraintdeclarationvalidationprocess-validationroutine-traversable-jparesolver">
        <title>Java Persistence aware TraversableResolver</title>

        <programlisting>public class JPATraversableResolver implements TraversableResolver {

    public boolean isReachable(Object traversableObject,
                               Path.Node traversableProperty,
                               Class&lt;?&gt; rootBeanType,
                               Path pathToTraversableObject,
                               ElementType elementType) {
        return traversableObject == null ||
                Persistence.getPersistenceUtil().isLoaded(
                        traversableObject,
                        traversableProperty.getName() );
    }

    public boolean isCascadable(Object traversableObject,
                               Path.Node traversableProperty,
                               Class&lt;?&gt; rootBeanType,
                               Path pathToTraversableObject,
                               ElementType elementType) {
        return true;
    }
}</programlisting>
      </example>

      <para>See <xref linkend="bootstrapping"/> to <phrase
      revisionflag="changed">learn</phrase> how to pass a custom
      <classname>TraversableResolver</classname>.</para>

      <section id="constraintdeclarationvalidationprocess-validationroutine-traversable-examples">
        <title>Examples</title>

        <para>The following example assumes the object graph defined in <xref
        linkend="example-ognav-definitions"/> and assumes the validation
        operation is applied on an address object.</para>

        <example id="example-ognav-definitions">
          <title>Definitions used in the example</title>

          <programlisting>public class Country {
    @NotNull private String name;
    @Size(max=2) private String ISO2Code;
    @Size(max=3) private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Size(max=30)
    private String addressline1;
    @Size(max=30)
    private String addressline2;
    @Size(max=11)
    private String zipCode;
    @Valid
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}</programlisting>
        </example>

        <para>When the Bean Validation provider is about to check constraints
        of <literal>ISO3Code</literal>, it calls the
        <classname>TraversableResolver.isReachable()</classname> method to
        ensure that the <literal>ISO3Code</literal> property is reachable with
        the following parameter values:</para>

        <itemizedlist>
          <listitem>
            <para><literal>traversableObject</literal>: country. The instance
            returned by <code>address.getCountry()</code>.</para>
          </listitem>

          <listitem>
            <para><literal>traversableProperty</literal>: a<phrase
            revisionflag="changed"> <classname>PropertyNode</classname>
            </phrase>whose name is "ISO3Code". <phrase
            revisionflag="changed">Represents the </phrase>property of
            <literal>traversableObject</literal> being verified.</para>
          </listitem>

          <listitem>
            <para><methodname>rootBeanType</methodname>:
            <classname>Address.class</classname>. The type of the root object
            being validated.</para>
          </listitem>

          <listitem>
            <para><literal>pathtoTraversableObject</literal>: a
            <classname>Path</classname> containing a single<phrase
            revisionflag="changed"> <classname>PropertyNode</classname>
            </phrase>whose name is "country". The path from address to the
            country instance.</para>
          </listitem>

          <listitem>
            <para><literal>elementType</literal>:
            <classname>ElementType.FIELD</classname>. The ISO3Code property is
            annotated on its field.</para>
          </listitem>
        </itemizedlist>

        <para>When the Bean Validation provider is about to cascade validation
        on <literal>country</literal> (<classname>Address</classname> object),
        it calls the <classname>TraversableResolver.isReachable()</classname>
        method to ensure that the <literal>country</literal> property is
        reachable and if this method returns <literal>true</literal>, it calls
        <classname>TraversableResolver.isCascadable()</classname> with the
        following parameter values:</para>

        <itemizedlist>
          <listitem>
            <para><literal>traversableObject</literal>: address. The address
            instance.</para>
          </listitem>

          <listitem>
            <para><literal>traversableProperty</literal>: a<phrase
            revisionflag="changed"> <classname>PropertyNode</classname>
            </phrase>whose name is "country". <phrase>Represents the</phrase>
            property of <literal>traversableObject</literal> being
            verified.</para>
          </listitem>

          <listitem>
            <para><methodname>rootBeanType</methodname>:
            <classname>Address.class</classname>. The type of the root object
            being validated.</para>
          </listitem>

          <listitem>
            <para><literal>pathtoTraversableObject</literal>: a
            <classname>Path</classname> containing a single<phrase
            revisionflag="changed"> <classname>BeanNode</classname>
            </phrase>whose name is <literal>null</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>elementType</literal>:
            <classname>ElementType.FIELD</classname>. The country property is
            annotated on its field.</para>
          </listitem>
        </itemizedlist>

        <para revisionflag="added">The following example shows invocations of
        the <classname>TraversableResolver</classname> as to be performed by
        the Bean Validation provider during method validation. The example is
        based on the object graph defined in <xref
        linkend="example-ognav-definitions"/> and the
        <classname>AddressService</classname> class shown in <xref
        linkend="example-ognav-definitions-methodvalidation"/>. It assumes
        that a call of <methodname>persistAddress()</methodname> is subject to
        method parameter validation.</para>

        <example id="example-ognav-definitions-methodvalidation"
                 revisionflag="added">
          <title>Examplary class <classname>AddressService</classname></title>

          <programlisting>public class AddressService {
    public void persistAddress(@NotNull @Valid Address address) {
        [...]
    }
}</programlisting>
        </example>

        <para revisionflag="added">When the Bean Validation provider is about
        to validate the <classname>@NotNull</classname> constraint on the
        <varname>address</varname> parameter, no call to
        <methodname>isReachable()</methodname> is expected, since parameters
        are assumed to always be reachable. Similarly, no call to
        <methodname>isCascable()</methodname> is expected when performing
        cascaded validation of the <varname>address</varname> parameter, since
        parameters are assumed to always be cascadable.</para>

        <para revisionflag="added">When the Bean Validation provider is about
        to validate constraints on the field <varname>addressline1</varname>
        of the passed <classname>Address</classname> object, it calls the
        <methodname>isReachable()</methodname> method to ensure that the
        property is reachable with the following parameter values:</para>

        <itemizedlist revisionflag="added">
          <listitem>
            <para><literal>traversableObject</literal>: address. The instance
            passed to <methodname>persistAddress()</methodname>.</para>
          </listitem>

          <listitem>
            <para><literal>traversableProperty</literal>: a
            <classname>PropertyNode</classname> whose name is "addressline1".
            Represents the property of <literal>traversableObject</literal>
            being verified.</para>
          </listitem>

          <listitem>
            <para><methodname>rootBeanType</methodname>:
            <classname>AddressService.class</classname>. The type of the root
            object being validated.</para>
          </listitem>

          <listitem>
            <para><literal>pathtoTraversableObject</literal>: a
            <classname>Path</classname> comprising a
            <classname>MethodNode</classname> (named "persistService") and a
            <classname>ParameterNode</classname> (with parameter index 0). The
            path from <classname>AddressService</classname> to the
            <classname>Address</classname> instance.</para>
          </listitem>

          <listitem>
            <para><literal>elementType</literal>:
            <classname>ElementType.FIELD</classname>. The
            <varname>addressline1</varname> property is annotated on its
            field.</para>
          </listitem>
        </itemizedlist>

        <para revisionflag="added">When the Bean Validation provider is about
        to perform a cascaded validation of the <varname>country</varname>
        property of the passed <classname>Address</classname> object, it calls
        the <methodname>isReachable()</methodname> method to ensure that the
        property is reachable. If this method returns
        <literal><literal>true</literal></literal>, it calls
        <classname>TraversableResolver.isCascadable()</classname> with the
        following parameter values:</para>

        <itemizedlist revisionflag="added">
          <listitem>
            <para><literal>traversableObject</literal>: address. The instance
            passed to <methodname>persistAddress()</methodname>.</para>
          </listitem>

          <listitem>
            <para><literal>traversableProperty</literal>: a
            <classname>PropertyNode</classname> whose name is "country".
            Represents the property of <literal>traversableObject</literal>
            being verified.</para>
          </listitem>

          <listitem>
            <para><methodname>rootBeanType</methodname>:
            <classname>AddressService.class</classname>. The type of the root
            object being validated.</para>
          </listitem>

          <listitem>
            <para><literal>pathtoTraversableObject</literal>: a
            <classname>Path</classname> comprising a
            <classname>MethodNode</classname> (named "persistService") and a
            <classname>ParameterNode</classname> (with parameter index 0). The
            path from <classname>AddressService</classname> to the
            <classname>Address</classname> instance.</para>
          </listitem>

          <listitem>
            <para><literal>elementType</literal>:
            <classname>ElementType.FIELD</classname>. The
            <varname>country</varname> property is annotated on its
            field.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section id="typevalidatorresolution">
      <title>ConstraintValidator resolution algorithm</title>

      <para>A constraint is associated to one or more
      <classname>ConstraintValidator</classname> implementations. Each
      <classname>ConstraintValidator&lt;A, T&gt;</classname> accepts the type
      <classname>T</classname>. The <classname>ConstraintValidator</classname>
      executed depends on the type hosting the constraint. For a given
      constraint evaluation, a single
      <classname>ConstraintValidator</classname> is considered.</para>

      <para>The list of <classname>ConstraintValidator</classname>s can
      contain at most one which targets cross-parameter. If the constraint
      targets the parameters of an executable either implicitly or by the use
      of <methodname>validationAppliesTo</methodname> in the constraint - see
      <xref
      linkend="constraintsdefinitionimplementation-constraintdefinition-validationappliesto"/>,
      then the cross-parameter <classname>ConstraintValidator</classname> is
      used. If none is present, an exception is raised.</para>

      <para><phrase role="tck-testable">If the constraint is a generic
      constraint, the following rules apply. If the constraint declaration is
      hosted on a class or an interface, the targeted type is the class or the
      interface.</phrase> <phrase role="tck-testable">If the constraint is
      hosted on a class attribute, the type of the attribute is the targeted
      type.</phrase> <phrase role="tck-testable">If the constraint is hosted
      on a getter, the return type of the getter is the targeted
      type.</phrase> In other words, the resolution algorithm considers the
      type as defined in the method signature and not the runtime type of the
      value.</para>

      <para>The rules written below describe formally the following statement:
      <phrase role="tck-testable">the
      <classname>ConstraintValidator</classname> chosen to validate the
      generic constraint on a declared type <classname>T</classname> is the
      one where the <classname>ConstraintValidator</classname> targets the
      annotated element, where the type supported by the
      <classname>ConstraintValidator</classname> is a supertype of
      <classname>T</classname> and where there is no other
      <classname>ConstraintValidator</classname> whose supported type is a
      supertype of <classname>T</classname> and not a supertype of the chosen
      <classname>ConstraintValidator</classname> supported
      type.</phrase></para>

      <para>When validating a generic constraint A placed on a target
      declaring the type <classname>T</classname>, the following resolution
      rules apply:</para>

      <itemizedlist>
        <listitem revisionflag="added" role="tck-testable">
          <para>Only <classname>ConstraintValidator</classname>
          implementations targeting annotated elements are considered.</para>
        </listitem>

        <listitem role="tck-testable">
          <para>Primitive types are considered equivalent to their respective
          primitive wrapper class. Likewise, arrays of primitive types are
          considered equivalent to arrays of their wrapper classes.</para>
        </listitem>

        <listitem>
          <para>A <classname>ConstraintValidator&lt;A, U&gt;</classname> is
          said to be <emphasis>compliant</emphasis> with
          <classname>T</classname> if <classname>T</classname> is a subtype of
          <classname>U</classname> (according to the<ulink
          url="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10">
          Java Language Specification 3rd edition chapter 4.10
          Subtyping</ulink>). Note that <classname>T</classname> is a subtype
          of <classname>U</classname> if <classname>T</classname> =
          <classname>U</classname>.</para>
        </listitem>

        <listitem role="tck-testable">
          <para role="tck-testable">If no
          <classname>ConstraintValidator</classname> compliant with
          <classname>T</classname> is found amongst the
          <classname>ConstraintValidator</classname>s listed by the constraint
          <classname>A</classname>, an
          <classname>UnexpectedTypeException</classname> is raised.</para>
        </listitem>

        <listitem role="tck-testable">
          <para>A <classname>ConstraintValidator&lt;A, U&gt;</classname>
          compliant with <classname>T</classname> is considered
          <emphasis>strictly more specific</emphasis> than a
          <classname>ConstraintValidator&lt;A, V&gt;</classname> compliant
          with <classname>T</classname> if <classname>U</classname> is a
          strict subtype of <classname>V</classname>. <classname>U</classname>
          is a strict subtype of <classname>V</classname> if
          <classname>U</classname> is a subtype of <classname>V</classname>
          and <classname>U</classname> != <classname>V</classname> (according
          to the <ulink
          url="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10">Java
          Language Specification 3rd edition chapter 4.10
          Subtyping</ulink>).</para>
        </listitem>

        <listitem>
          <para>A <classname>ConstraintValidator&lt;A, U&gt;</classname>
          compliant with <classname>T</classname> is considered maximally
          specific if no other <classname>ConstraintValidator&lt;A,
          V&gt;</classname> compliant with <classname>T</classname> is
          strictly more specific than <classname>ConstraintValidator&lt;A,
          U&gt;</classname>.</para>
        </listitem>

        <listitem>
          <para role="tck-testable">If more than one maximally specific
          <classname>ConstraintValidator</classname> is found, an
          <classname>UnexpectedTypeException</classname> is raised.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>While the Java compiler itself cannot determine if a constraint
        declaration will lead to a
        <classname>UnexpectedTypeException</classname>, rules can be
        statically checked. A tool such as an IDE or a Java 6 annotation
        processor can apply these rules and prevent compilation in case of
        ambiguity. The specification encourages Bean Validation providers to
        provide such a tool to their users.</para>
      </note>

      <para>Let's see a couple of declarations and their respective
      <classname>ConstraintValidator</classname> resolution. Assuming the
      definitions shown in <xref
      linkend="example-constraintvalidator-resolution"/>:</para>

      <example id="example-constraintvalidator-resolution">
        <title>ConstraintValidator and type resolution</title>

        <programlisting>[...]
@Constraint(validatedBy={
    SizeValidatorForCollection.class,
    SizeValidatorForSet.class,
    SizeValidatorForSerializable.class })
public @interface Size { ...}

public class SizeValidatorForCollection implements ConstraintValidator&lt;Size, Collection&gt; {
    [...]
}
public class SizeValidatorForSet implements ConstraintValidator&lt;Size, Set&gt; {
    [...]
}
public class SizeValidatorForSerializable implements ConstraintValidator&lt;Size, Serializable&gt; {
    [...]
}

public interface SerializableCollection extends Serializable, Collection {
}</programlisting>
      </example>

      <para>The resolutions shown in <xref
      linkend="table-constraintvalidator-resolution"/> occur.</para>

      <table id="table-constraintvalidator-resolution">
        <title>Resolution of ConstraintValidator for various constraints
        declarations</title>

        <tgroup cols="2">
          <colspec align="center"/>

          <thead>
            <row>
              <entry>Declaration</entry>

              <entry>Resolution</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>@Size Collection getAddresses() { [...]
              }</code></entry>

              <entry><classname>SizeValidatorForCollection</classname>: direct
              match</entry>
            </row>

            <row>
              <entry><code>@Size Collection&lt;?&gt; getAddresses() { [...]
              }</code></entry>

              <entry><classname>SizeValidatorForCollection</classname>:
              <classname>Collection</classname> is a direct supertype of
              <classname>Collection&lt;?&gt;</classname></entry>
            </row>

            <row>
              <entry><code>@Size Collection&lt;Address&gt; getAddresses() {
              [...] }</code></entry>

              <entry><classname>SizeValidatorForCollection</classname>:
              <classname>Collection</classname> is a direct supertype of
              <classname>Collection&lt;Address&gt;</classname></entry>
            </row>

            <row>
              <entry><code>@Size Set&lt;Address&gt; getAddresses() { [...]
              }</code></entry>

              <entry><classname>SizeValidatorForSet</classname>: direct
              supertype of <classname>Set&lt;Address&gt;</classname></entry>
            </row>

            <row>
              <entry><code>@Size SortedSet&lt;Address&gt; getAddresses() {
              [...] }</code></entry>

              <entry><classname>SizeValidatorForSet</classname>:
              <classname>Set</classname> is the closest supertype of
              <classname>SortedSet&lt;Address&gt;</classname></entry>
            </row>

            <row>
              <entry><code>@Size SerializableCollection getAddresses() { [...]
              }</code></entry>

              <entry><classname>UnexpectedTypeException</classname>:
              <classname>SerializableCollection</classname> is a subtype of
              both <classname>Collection</classname> and
              <classname>Serializable</classname> and neither
              <classname>Collection</classname> nor
              <classname>Serializable</classname> are subtypes of each
              other.</entry>
            </row>

            <row>
              <entry><code>@Size String getName() { [...] }</code></entry>

              <entry><classname>UnexpectedTypeException</classname>: none of
              the <classname>ConstraintValidator</classname> types are
              supertypes of <classname>String</classname>.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>

  <section>
    <title>Examples</title>

    <para>The first example demonstrates how beans, fields and getters are
    annotated to express some constraints.</para>

    <example>
      <title>Place constraint declarations on the element to validate</title>

      <programlisting>@ZipCodeCityCoherenceChecker
public class Address {
    @NotNull @Size(max=30)
    private String addressline1;

    @Size(max=30)
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}</programlisting>
    </example>

    <para>During the validation routine execution on an
    <classname>Address</classname> object,</para>

    <itemizedlist>
      <listitem>
        <para><methodname>addressline1</methodname> field value is passed to
        the <classname>@NotNull</classname> as well as
        <classname>@Size</classname> constraint validation
        implementation.</para>
      </listitem>

      <listitem>
        <para><methodname>addressline2</methodname> field value is passed to
        the <classname>@Size</classname> constraint validation
        implementation.</para>
      </listitem>

      <listitem>
        <para><methodname>getCity</methodname> value is passed to the
        <classname>@Size</classname> and <classname>@NotNull</classname>
        constraint validation implementations</para>
      </listitem>

      <listitem>
        <para><classname>@ZipCodeCoherenceChecker</classname> is a constraint
        whose validation implementation's <methodname>isValid</methodname>
        method receives the <classname>Address</classname> object</para>
      </listitem>
    </itemizedlist>

    <para>The second example demonstrates object graph validation</para>

    <example>
      <title>Define object graph validation</title>

      <programlisting>public class Country {
    @NotNull
    private String name;
    @Size(max=2) private String ISO2Code;
    @Size(max=3) private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Size(max=30)
    private String addressline1;
    @Size(max=30)
    private String addressline2;
    @Size(max=11)
    private String zipCode;
    <emphasis role="bold">@NotNull @Valid</emphasis>
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}</programlisting>
    </example>

    <para>During the validation routine execution on an
    <classname>Address</classname> object, constraints on
    <methodname>addressLine1</methodname>,
    <methodname>addressLine2</methodname>, <methodname>zipCode</methodname>,
    <classname>getCity</classname> and <methodname>country</methodname> are
    processed as well as the validation of the <classname>Country</classname>
    object itself, more specifically <methodname>country.name</methodname> is
    checked for <classname>@NotNull</classname>,
    <methodname>ISO2Code</methodname> and <methodname>ISO3Code</methodname>
    are checked for <classname>@Size</classname>.</para>

    <para>Assuming that <classname>@NotEmpty</classname> is defined as
    such</para>

    <programlisting>package com.acme.constraint;

@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmpty.NotEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface NotEmpty {
    String message() default "{com.acme.constraint.NotEmpty.message}"
    Class&lt;?&gt; groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotEmpty[] value();
    }    

    class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; {
        public void initialize(NotEmpty constraintAnnotation) {}

        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}</programlisting>

    <para>The third example demonstrates superclass, inheritance and composite
    constraints.</para>

    <example>
      <title>Use inheritance, constraints on superclasses and composite
      constraints</title>

      <programlisting>public interface Person {
    @NotEmpty
    String getFirstName();

    String getMiddleName();
    
    @NotEmpty
    String getLastName();
}

public class Customer implements Person {
    private String firstName;
    private String middleName;
    private String lastName;
    @NotNull
    private String customerId;
    @Password(robustness=5)
    private String password;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getMiddleName() {
        return middleName;
    }

    public void setMiddleName(String middleName) {
        this.middleName = middleName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

public class PreferredGuest extends Customer {
    @CreditCard
    private String guestCreditCardNumber;

    public String getGuestCreditCardNumber() {
        return guestCreditCardNumber;
    }

    public void setGuestCreditCardNumber(String guestCreditCardNumber) {
        this.guestCreditCardNumber = guestCreditCardNumber;
    }
}

public class CommonGuest extends customer {}</programlisting>
    </example>

    <para>When validating a <classname>PreferredGuest</classname> the
    following constraints are processed:</para>

    <itemizedlist>
      <listitem>
        <para><classname>@NotEmpty</classname>,
        <classname>@NotNull</classname> and
        <classname>@Size(min=1)</classname> on
        <methodname>firstName</methodname></para>
      </listitem>

      <listitem>
        <para><classname>@NotEmpty</classname>,
        <classname>@NotNull</classname> and
        <classname>@Size(min=1)</classname> on
        <methodname>lastName</methodname></para>
      </listitem>

      <listitem>
        <para><classname>@NotNull</classname> on
        <methodname>customerId</methodname>, <classname>@Password</classname>
        on <methodname>password</methodname></para>
      </listitem>

      <listitem>
        <para><classname>@CreditCard</classname> on
        <methodname>guestCreditCardNumber</methodname></para>
      </listitem>
    </itemizedlist>

    <para>When validating <classname>CommonGuest</classname>, the following
    constraints are processed:</para>

    <itemizedlist>
      <listitem>
        <para><classname>@NotEmpty</classname>,
        <classname>@NotNull</classname> and
        <classname>@Size(min=1)</classname> on
        <methodname>firstName</methodname></para>
      </listitem>

      <listitem>
        <para><classname>@NotEmpty</classname>,
        <classname>@NotNull</classname> and
        <classname>@Size(min=1)</classname> on
        <methodname>lastName</methodname></para>
      </listitem>

      <listitem>
        <para><classname>@NotNull</classname> on
        <methodname>customerId</methodname>, <classname>@Password</classname>
        on <methodname>password</methodname></para>
      </listitem>
    </itemizedlist>

    <para>The fourth example demonstrates the influence of group
    sequence.</para>

    <example>
      <title>Use groups and group sequence to define constraint
      ordering</title>

      <programlisting><emphasis role="bold">@GroupSequence({First.class, Second.class, Last.class})</emphasis>
public interface Complete {}

public class Book {
    @NotEmpty(groups=First.class)
    private String title;

    @Size(max=30, groups=Second.class)
    private String subtitle;

    @Valid
    @NotNull(groups=First.class)
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getSubtitle() {
        return subtitle;
    }

    public void setSubtitle(String subtitle) {
        this.subtitle = subtitle;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

public class Author {
    @NotEmpty(groups=Last.class)
    private String firstName;
    
    @NotEmpty(groups=First.class)
    private String lastName;

    @Size(max=30, groups=Last.class)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}</programlisting>
    </example>

    <para>Assuming the validation of the <classname>Complete</classname> group
    on the following book instance:</para>

    <programlisting>Author author = new Author();
author.setLastName( "Baudelaire" );
author.setFirstName( "" );
Book book = new Book();
book.setAuthor( author );</programlisting>

    <para>the validation routine will return the following failure:</para>

    <itemizedlist>
      <listitem>
        <para><classname>@NotNull</classname> failure (from
        <classname>@NotEmpty</classname>) on the <literal>title</literal>
        field</para>
      </listitem>
    </itemizedlist>

    <para>As both <methodname>title</methodname> and
    <methodname>author.lastname</methodname> are checked as part of the
    <literal><classname>First</classname></literal> group. If the instance is
    updated:</para>

    <programlisting>book.setTitle( "Les fleurs du mal" );
author.setCompany("Some random publisher with a very very very long name");</programlisting>

    <para>the validation routine will return the following failures:</para>

    <itemizedlist>
      <listitem>
        <para><methodname>author.firstName</methodname> fails to pass the
        <classname>@Size(min=1)</classname> (from
        <classname>@NotEmpty</classname>) constraint</para>
      </listitem>

      <listitem>
        <para><methodname>author.company</methodname> fails to pass the
        <classname>@Size</classname> constraint</para>
      </listitem>
    </itemizedlist>

    <para>As the <classname>First</classname> and
    <classname>Second</classname> groups pass without failure, the
    <classname>Last</classname> group is going through validation.</para>
  </section>
</chapter>
