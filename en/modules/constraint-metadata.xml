<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../docbook-support/support/docbook-dtd/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../global.ent">
%BOOK_ENTITIES;
]>
<chapter id="constraintmetadata">
  <title>Constraint metadata request APIs</title>

  <para>The Bean Validation specification provides a way to query the
  constraint repository. This API is expected to be used for tooling support
  as well as integration with other frameworks, libraries and JSRs. The Bean
  Validation specification aims to provide both a validation engine and a
  metadata repository for object constraints. Frameworks (EE or SE) in need
  for constraint definition, validation and metadata will be able to rely on
  the Bean Validation specification for these services avoiding any
  unnecessary duplication work from an application and infrastructure point of
  view.</para>

  <section>
    <title>Validator</title>

    <para>The main API to access all metadata related to a given object is
    <classname>Validator</classname> (see <xref linkend="bootstrapping"/> for
    more information on how to retrieve a <classname>Validator</classname>
    instance).</para>

    <para>A <classname>Validator</classname> instance hosts the method to
    access to the metadata repository for a given class. It is recommended to
    leave the caching of <classname>Validator</classname> instances to the
    <classname>ValidatorFactory</classname>. <classname>Validator</classname>
    implementations are thread-safe.</para>

    <example revisionflag="changed">
      <title>Validator interface (metadata request API)</title>

      <programlisting>/**
 * Validate bean instances. Implementations of this interface must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface Validator {

    [...] //See 5.1

    /**
     * Return the descriptor object describing bean constraints.
     * The returned object (and associated objects including
     * {@code ConstraintDescriptor}s) are immutable.
     *
     * @param clazz class or interface type evaluated
     *
     * @return the bean descriptor for the specified class.
     *
     * @throws IllegalArgumentException if clazz is {@code null}
     * @throws ValidationException if a non recoverable error happens
     *                             during the metadata discovery or if some
     *                             constraints are invalid.
     */
    BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);
}</programlisting>
    </example>

    <para><phrase
    role="tck-testable"><methodname>getConstraintsForClass</methodname>
    returns a <classname>BeanDescriptor</classname> object describing the bean
    level constraints (see <xref
    linkend="constraintdeclarationvalidationprocess-requirements-object"/>)
    and providing access to the property level constraints metadata.
    </phrase><phrase revisionflag="added" role="tck-testable">An
    <classname>IllegalArgumentException</classname> is raised if the
    <varname>clazz</varname> parameter is null.</phrase></para>

    <para><phrase role="tck-testable">If a constraint definition or
    declaration hosted by the requested class (or any of it's superclasses and
    interfaces according to the constraint propagation rules) is invalid, a
    <classname>ValidationException</classname> is raised.</phrase> This can be
    a subclass of <classname>ValidationException</classname> like
    <classname>ConstraintDefinitionException</classname>,
    <classname>ConstraintDeclarationException</classname>,
    <classname>UnexpectedTypeException</classname>.</para>

    <para revisionflag="added">All descriptor types accessible via
    <methodname>getConstraintsForClass()</methodname> and introduced in the
    following sections are located in the package
    <classname>javax.validation.metadata</classname>.</para>
  </section>

  <section id="constraintmetadata-elementdescriptor">
    <title>ElementDescriptor</title>

    <para revisionflag="changed"><classname>ElementDescriptor</classname> is
    the root interface describing elements hosting constraints. It is used to
    describe the list of constraints for a given element (whether it be a
    class, property, method etc.).</para>

    <example revisionflag="changed">
      <title>ElementDescriptor interface</title>

      <programlisting>package javax.validation.metadata;

/**
 * Describes a validated element (class, property, method etc.).
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface ElementDescriptor {

    /**
     * @return Return {@code true} if at least one constraint declaration is present
     *         for this element in the class hierarchy, {@code false} otherwise.
     */
    boolean hasConstraints();

    /**
     * @return Statically defined returned type.
     */
    Class&lt;?&gt; getElementClass();

    /**
     * Return all constraint descriptors for this element in the class hierarchy
     * or an empty {@code Set} if none are present.
     *
     * @return {@code Set} of constraint descriptors for this element
     */
    Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getConstraintDescriptors();

    /**
     * Find constraints and potentially restricts them to certain criteria.
     *
     * @return ConstraintFinder object.
     */
    ConstraintFinder findConstraints();

    /**
     * Declare restrictions on retrieved constraints.
     * Restrictions are cumulative.
     *
     * A {@code ConstraintFinder} is not thread-safe. The set of matching
     * {@code ConstraintDescriptor} is.
     */
    interface ConstraintFinder {
        /**
         * Restrict to the constraints matching a given set of groups for this element
         *
         * This method respects group conversion, group sequences
         * and group inheritance (including class-level {@code Default} group
         * overriding) but does not return {@code ConstraintDescriptor}s
         * in any particular order.
         * Specifically, ordering of the group sequence is not respected.
         *
         * @param groups groups targeted
         *
         * @return {@code this} following the chaining method pattern
         */
        ConstraintFinder unorderedAndMatchingGroups(Class&lt;?&gt;... groups);

        /**
         * Restrict to the constraints matching the provided scope for this element.
         *
         * Defaults to {@code Scope.HIERARCHY}
         *
         * @param scope expected scope
         *
         * @return {@code this} following the chaining method pattern
         */
        ConstraintFinder lookingAt(Scope scope);

        /**
         * Restrict to the constraints hosted on the listed {@code types}
         * for a given element.
         *
         * Default to all possible types of the element.
         *
         * Typically used to restrict to fields ({@code FIELD})
         * or getters ({@code METHOD})
         *
         * @param types targeted types
         *
         * @return {@code this} following the chaining method pattern
         */
        ConstraintFinder declaredOn(ElementType... types);

        /**
         * Retrieve the constraint descriptors following the defined
         * restrictions and hosted on the element described by
         * {@code ElementDescriptor}
         *
         * @return matching constraint descriptors
         */
        Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getConstraintDescriptors();

        /**
         * Returns {@code true} if at least one constraint declaration
         * matching the restrictions is present on the element,
         * {@code false} otherwise.
         *
         * @return is there any constraint
         */
        boolean hasConstraints();
    }
}</programlisting>
    </example>

    <programlisting>package javax.validation.metadata;

/**
 * Scope looked at when discovering constraints
 *
 * @author Emmanuel Bernard
 */
public enum Scope {
    /**
     * Look for constraints declared on the current class element
     * and ignore inheritance and elements with the same name in
     * the class hierarchy.
     */
    LOCAL_ELEMENT,

    /**
     * Look for constraints declared on all elements of the class hierarchy
     * with the same name.
     */
    HIERARCHY
}</programlisting>

    <para revisionflag="changed"
    role="tck-testable tck-needs-update"><methodname>getElementClass</methodname>
    returns<itemizedlist>
        <listitem>
          <para>the object type when invoked on
          <classname>BeanDescriptor</classname>,</para>
        </listitem>

        <listitem>
          <para>the type of a property or parameter when invoked on
          <classname>PropertyDescriptor</classname> or
          <classname>ParameterDescriptor</classname> respectively,</para>
        </listitem>

        <listitem>
          <para><literal>Object[].class</literal> when invoked on
          <classname>CrossParameterDescriptor</classname>,</para>
        </listitem>

        <listitem>
          <para>the return type when invoked on
          <classname>ConstructorDescriptor</classname>,
          <classname>MethodDescriptor</classname> or
          <classname>ReturnValueDescriptor</classname>.</para>
        </listitem>
      </itemizedlist></para>

    <para role="tck-testable"><classname>getConstraintDescriptors</classname>
    returns all the <classname>ConstraintDescriptor</classname>s (see <xref
    linkend="constraintmetadata-constraintdescriptor"/>) hosted on the given
    element in the class hierarchy, each
    <classname>ConstraintDescriptor</classname> describing one of the
    constraints declared on the given element.</para>

    <para role="tck-testable"><methodname>hasConstraints</methodname> returns
    true if the given element in the class hierarchy holds at least one
    constraint declaration.</para>

    <para role="tck-testable">If you need to query the metadata API in a more
    fine grained way for example by restricting the constraints to the one
    described on fields or on getters or by restricting to a given set of
    groups, you can use the <classname>ConstraintFinder</classname> fluent API
    by calling <methodname>findConstraints</methodname>.</para>

    <para
    role="tck-testable"><classname>unorderedAndMatchingGroups</classname>
    restricts the results to the <classname>ConstraintDescriptor</classname>s
    (see <xref linkend="constraintmetadata-constraintdescriptor"/>) matching
    the given groups. Order is not respected but group inheritance and
    inheritance via sequence (including the <classname>Default</classname>
    group overriding at the class level) are honored.</para>

    <para><phrase role="tck-testable"><methodname>declaredOn</methodname> lets
    you restrict the list of element types constraints are hosted on.</phrase>
    This is particularly useful to retrieve <phrase
    revisionflag="added">property</phrase> constraints only hosted on fields
    (<classname>ElementType.FIELD</classname>) or only hosted on getters
    (<classname>ElementType.METHOD</classname>).</para>

    <para role="tck-testable"><methodname>lookingAt</methodname> lets you
    restrict which constraints are considered. Either constraints belonging to
    the element but hosted on the class represented by the given descriptor
    (<classname>Scope.LOCAL_ELEMENT</classname>), or constraints belonging to
    the element but hosted anywhere in the class hierarchy
    (<classname>Scope.HIERARCHY</classname>).</para>

    <para>Here is an example restricting the list of constraints on getters,
    matching the default group and declared physically on the
    <literal>name</literal> getter of <classname>Customer</classname> (and not
    any of the getters on the super classes).</para>

    <example>
      <title>Using the fluent API to restrict matching constraints</title>

      <programlisting>public class User {
    @Size(max=50) 
    String getName() { ... }
    ...
}

public class Customer extends User {
    @NotNull
    String getName() { ... }
}

PropertyDescriptor pd = 
    validator.getConstraintsForClass(Customer.class).getConstraintsForProperty("name");
Set&lt;ConstraintDescriptor&lt;?&gt;&gt; constraints = 
    pd.findConstraints()
        .declaredOn(ElementType.METHOD)
        .unorderedAndMatchingGroups(Default.class)
        .lookingAt(Scope.LOCAL_ELEMENT)
        .getConstraintDescriptors();

assert 1 == constraints.size();

constraints = pd.getConstraintDescriptors();
//equivalent to pd.findConstraints().getConstraintDescriptors();
assert 2 == constraints.size();</programlisting>
    </example>

    <para revisionflag="added">The following example shows how the fluent API
    is used to retrieve parameter, cross-parameter and return value
    constraints, taking into account locally declared constraints as well as
    constraints declared in the inheritance hierarchy.</para>

    <example revisionflag="added">
      <title>Using the fluent API to select method and constructor
      constraints</title>

      <programlisting>public class User {

    public User(@Size(max=50) String name) { ... }

    @PasswordParametersMatch
    @NotNull
    public String resetPassword(
        @NotNull @Size(min=8) String password,
        @NotNull @Size(min=8) String confirmation) { ... }
}

public class Customer extends User {

    public Customer(@NotNull String name) { ... }

    @Size(min=8)
    public String resetPassword(String password, String confirmation) { ... }
}

MethodDescriptor methodDescriptor = validator
    .getConstraintsForClass( Customer.class )
    .getConstraintsForMethod( "resetPassword", String.class, String.class );

//one cross-parameter constraint
assert 1 == methodDescriptor.getCrossParameterDescriptor().getConstraintDescriptors().size();

//one local return value constraint
assert 1 == methodDescriptor.getReturnValueDescriptor()
    .findConstraints()
    .lookingAt( Scope.LOCAL_ELEMENT )
    .getConstraintDescriptors()
    .size();

//two return value constraints in the complete hierarchy
assert 2 == methodDescriptor.getReturnValueDescriptor()
    .findConstraints()
    .lookingAt( Scope.HIERARCHY )
    .getConstraintDescriptors()
    .size();

//two parameter constraints, defined on overridden method
assert 2 == methodDescriptor.getParameterDescriptors()
    .get( 0 )
    .getConstraintDescriptors()
    .size();

ConstructorDescriptor constructorDescriptor = validator
    .getConstraintsForClass( Customer.class )
    .getConstraintsForConstructor( String.class );

//one parameter constraint; constraints from super constructor don't apply
assert 1 == constructorDescriptor.getParameterDescriptors()
    .get( 0 )
    .findConstraints()
    .lookingAt( Scope.HIERARCHY )
    .getConstraintDescriptors()
    .size();</programlisting>
    </example>
  </section>

  <section>
    <title>BeanDescriptor</title>

    <para>The <classname>BeanDescriptor</classname> interface describes a
    constrained Java Bean. This interface is returned by
    <methodname>Validator.getConstraintsForClass(Class&lt;?&gt;)</methodname>.</para>

    <example revisionflag="changed">
      <title>BeanDescriptor interface</title>

      <programlisting>package javax.validation.metadata;

/**
 * Describes a constrained Java Bean and the constraints associated to it. All
 * objects returned by the methods of this descriptor (and associated objects
 * including {@code ConstraintDescriptor}s) are immutable.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 */
public interface BeanDescriptor extends ElementDescriptor {
    /**
     * Returns {@code true} if the bean involves validation:
     * &lt;ul&gt;
     * &lt;li&gt; a constraint is hosted on the bean itself &lt;/li&gt;
     * &lt;li&gt; a constraint is hosted on one of the bean properties&lt;/li&gt;
     * &lt;li&gt; a bean property is marked for cascaded validation ({@code @Valid})&lt;/li&gt;
     * &lt;li&gt; a constraint is hosted on the return value or a method parameter of one of the bean's methods&lt;/li&gt;
     * &lt;li&gt; or the return value or a method parameter of one of the bean's methods is marked for cascaded validation ({@code @Valid})&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@code true} if the bean involves validation, {@code false} otherwise.
     */
    boolean isBeanConstrained();

    /**
     * Return the property descriptor for a given property.
     * Return {@code null} if the property does not exist or has no
     * constraint nor is marked as cascaded (see {@link #getConstrainedProperties()} )
     * Properties of super types are considered.
     * &lt;p/&gt;
     *
     * @param propertyName property evaluated
     *
     * @return the property descriptor for a given property.
     *
     * @throws IllegalArgumentException if propertyName is {@code null}
     */
    PropertyDescriptor getConstraintsForProperty(String propertyName);

    /**
     * Returns a set of property descriptors having at least one constraint defined
     * or marked as cascaded ({@code @Valid}). If not property matches,
     * an empty set is returned.
     * Properties of super types are considered.
     *
     * @return Returns the set of {@code PropertyDescriptor}s for the constraint properties. If there are no
     *         constraint properties the empty set is returned
     */
    Set&lt;PropertyDescriptor&gt; getConstrainedProperties();

    /**
     * Returns a method descriptor for the given method. Returns {@code null} if
     * no method with the given name and parameter types exists or the specified
     * method neither has parameter or return value constraints nor a parameter
     * or return value marked for cascaded validation.
     * Methods of super types are considered.
     *
     * @param methodName The name of the method.
     * @param parameterTypes The parameter types of the method.
     *
     * @return A method descriptor for the given method.
     *
     * @throws IllegalArgumentException if methodName is {@code null}
     * @since 1.1
     */
    MethodDescriptor getConstraintsForMethod(String methodName, Class&lt;?&gt;... parameterTypes);

    /**
     * Returns a set with descriptors for the constrained methods of the type
     * represented by this descriptor. Constrained are all those methods which
     * have at least one parameter or return value constraint or at least one
     * parameter or return value marked for cascaded validation.
     * Methods of super types are considered.
     *
     * @return A set with descriptors for the constrained methods of this type.
     *         Will be empty if this type has no constrained methods but never
     *         {@code null}.
     *
     * @since 1.1
     */
    Set&lt;MethodDescriptor&gt; getConstrainedMethods();

    /**
     * Returns a constructor descriptor for the given constructor. Returns
     * {@code null} if no constructor with the given parameter types exists or
     * the specified constructor neither has parameter or return value
     * constraints nor a parameter or return value marked for cascaded
     * validation.
     * Constructor of super types are considered.
     *
     * @param parameterTypes The parameter types of the constructor.
     *
     * @return A constructor descriptor for the given constructor.
     *
     * @since 1.1
     */
    ConstructorDescriptor getConstraintsForConstructor(Class&lt;?&gt;... parameterTypes);

    /**
     * Returns a set with descriptors for the constrained constructors of the
     * type represented by this descriptor. Constrained are all those
     * constructors which have at least one parameter or return value constraint
     * or at least one parameter or return value marked for cascaded validation.
     *
     * @return A set with descriptors for the constrained constructor of this
     *         type. Will be empty if this type has no constrained constructor
     *         but never {@code null}.
     *
     * @since 1.1
     */
    Set&lt;ConstructorDescriptor&gt; getConstrainedConstructors();
}</programlisting>
    </example>

    <para><phrase
    role="tck-testable"><methodname>isBeanConstrained</methodname> returns
    true if the given class (and superclasses and interfaces) hosts at least
    one validation declaration (either constraint or
    <classname>@Valid</classname> annotation).</phrase> If the method returns
    false, the Bean Validation engine can safely ignore the bean as it will
    not be impacted by validation.</para>

    <para revisionflag="added"><remark>TODO: Specify behavior with respect to
    method constraints, or add a dedicated method for that (see <ulink
    url="http://lists.jboss.org/pipermail/beanvalidation-dev/2012-January/000239.html">http://lists.jboss.org/pipermail/beanvalidation-dev/2012-January/000239.html</ulink>)</remark></para>

    <para><phrase
    role="tck-testable"><methodname>getConstraintsForProperty</methodname>
    returns a <classname>PropertyDescriptor</classname> object describing the
    property level constraints (See <xref
    linkend="constraintdeclarationvalidationprocess-requirements-property"/>).
    The property is uniquely identified by its name as per the JavaBeans
    convention: field level and getter level constraints of the given name are
    all returned. </phrase><phrase revisionflag="added" role="tck-testable">An
    <classname>IllegalArgumentException</classname> is raised if the
    <varname>propertyName</varname> parameter is null.</phrase></para>

    <para><methodname>getConstrainedProperties</methodname> returns the
    <classname>PropertyDescriptor</classname>s of the bean properties having
    at least one constraint or being cascaded (<classname>@Valid</classname>
    annotation).</para>

    <para revisionflag="added"
    role="tck-testable"><methodname>getConstraintsForMethod</methodname>
    returns a <classname>MethodDescriptor</classname> object describing the
    method constraints of the given method. The method is uniquely identified
    by its name and the types of its parameters.</para>

    <para revisionflag="added"
    role="tck-testable"><methodname>getConstrainedMethods</methodname> returns
    the <classname>MethodDescriptor</classname>s of the methods having at
    least one constraint or cascaded parameter or return value.</para>

    <para revisionflag="added"
    role="tck-testable"><methodname>getConstraintsForConstructor</methodname>
    returns a <classname>ConstructorDescriptor</classname> object describing
    the method constraints of the given constructor. The constructor is
    uniquely identified by its name and the types of its parameters.</para>

    <para revisionflag="added"
    role="tck-testable"><methodname>getConstrainedConstructors</methodname>
    returns the <classname>ConstructorDescriptor</classname>s of the
    constructors having at least one constraint or cascaded parameter or
    return value.</para>
  </section>

  <section revisionflag="added">
    <title>CascadableDescriptor</title>

    <para>The <classname>CascadableDescriptor</classname> interface describes
    a cascadable element, i.e. an element which can be marked with
    <classname>@Valid</classname> in order to perform a cascaded validation of
    the element as described in <xref
    linkend="constraintdeclarationvalidationprocess-requirements-graphvalidation"/>.</para>

    <programlisting>package javax.validation.metadata;

/**
 * Represents a cascadable element.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface CascadableDescriptor {

    /**
     * Whether this element is marked for cascaded validation or not.
     *
     * @return {@code true}, if this element is marked for cascaded validation,
     *         {@code false} otherwise.
     */
    boolean isCascaded();

    /**
     * Returns the group conversions configured for this element.
     *
     * @return A set containing this element's group conversions. An empty set
     *         may be returned if no conversions are configured but never
     *         {@code null}.
     */
    Set&lt;GroupConversionDescriptor&gt; getGroupConversions();
}</programlisting>

    <para role="tck-testable">The <methodname>isCascaded</methodname> method
    returns <literal>true</literal> if the element is marked for cascaded
    validation.</para>

    <para role="tck-testable"><phrase role="tck-testable">The method
    <methodname>getGroupConversions</methodname> returns a set with the group
    conversions declared for the cascadable element.</phrase> <phrase
    role="tck-testable">An empty set will be returned if no group conversions
    are configured.</phrase></para>
  </section>

  <section revisionflag="added">
    <title>GroupConversionDescriptor</title>

    <para>The <classname>GroupConversionDescriptor</classname> interface
    describes a group conversion rule configured for a cascadable element as
    described in <xref
    linkend="constraintdeclarationvalidationprocess-groupsequence-groupconversion"/>.
    It is returned by
    <methodname>CascadableDescriptor.getGroupConversions</methodname>.</para>

    <programlisting>package javax.validation.metadata;

/**
 * A group conversion rule to be applied during cascaded validation. Two group
 * conversion descriptors are considered equal if they have the same
 * {@code from} and {@code to} group respectively.
 *
 * @author Gunnar Morling
 * @see ConvertGroup
 * @since 1.1
 */
public interface GroupConversionDescriptor {

    /**
     * Returns the source group of this conversion rule.
     *
     * @return The source group of this conversion rule.
     */
    Class&lt;?&gt; getFrom();

    /**
     * Returns the target group of this conversion rule.
     *
     * @return The target group of this conversion rule.
     */
    Class&lt;?&gt; getTo();
}</programlisting>

    <para role="tck-testable">The <methodname>getFrom</methodname> method
    returns the source of a group conversion rule.</para>

    <para role="tck-testable">The <methodname>getTo</methodname> method
    returns the target of a group conversion rule.</para>
  </section>

  <section>
    <title>PropertyDescriptor</title>

    <para>The <classname>PropertyDescriptor</classname> interface describes a
    constrained property of a Java Bean.</para>

    <para>This interface is returned by
    <methodname>BeanDescriptor.getConstraintsForProperty(String)</methodname>
    or <methodname>BeanDescriptor.getConstrainedProperties</methodname>.
    Constraints declared on the attribute and the getter of the same name
    according to the JavaBeans rules are returned by this descriptor.</para>

    <programlisting revisionflag="changed">package javax.validation.metadata;

/**
 * Describes a Java Bean property hosting validation constraints.
 *
 * Constraints placed on the attribute and the getter of a given property
 * are all referenced.
 *
 * @author Emmanuel Bernard
 */
public interface PropertyDescriptor extends ElementDescriptor, CascadableDescriptor {

    /**
     * Name of the property according to the Java Bean specification.
     *
     * @return property name.
     */
    String getPropertyName();
}</programlisting>

    <para role="tck-testable"><methodname>getPropertyName</methodname> returns
    the property name as described in <xref
    linkend="validationapi-constraintviolation"/>.</para>
  </section>

  <section revisionflag="added">
    <title>ExecutableDescriptor, MethodDescriptor and
    ConstructorDescriptor</title>

    <para>The <classname>ExecutableDescriptor</classname> interface describes
    a constrained method or constructor of a Java type.</para>

    <programlisting>package javax.validation.metadata;

/**
 * Provides common functionality of {@link MethodDescriptor} and
 * {@link ConstructorDescriptor}.
 *
 * @author Gunnar Morling
 *
 * @since 1.1
 */
public interface ExecutableDescriptor extends ElementDescriptor {

    /**
     * Returns the method name in case this descriptor represents a method or
     * the non-qualified name of the declaring class in case this descriptor
     * represents a constructor.
     *
     * @return The name of the executable represented by this descriptor.
     */
    String getName();

    /**
     * Returns a list with descriptors representing this executable's
     * parameters, in order of their declaration, including synthetic
     * parameters.
     *
     * @return A list with descriptors representing this executable's
     *         parameters. An empty list will be returned if this executable has
     *         no parameters, but never {@code null}.
     */
    List&lt;ParameterDescriptor&gt; getParameterDescriptors();

    /**
     * Returns a descriptor containing cross-parameter constraints
     * of this executable.
     *
     * @return A descriptor containing cross-parameter constraints of this
     *         executable
     */
    CrossParameterDescriptor getCrossParameterDescriptor();

    /**
     * Returns a descriptor for this executable's return value.
     * &lt;p/&gt;
     * An executable without return value will return a descriptor
     * representing {@code void}. This descriptor will have no constraint
     * associated.
     *
     * @return A descriptor for this executable's return value
     */
    ReturnValueDescriptor getReturnValueDescriptor();

    /**
     * Returns {@code true} if the executable parameters are constrained either:
     * &lt;ul&gt;
     * &lt;li&gt;because of a constraint on at least one of the parameters&lt;/li&gt;
     * &lt;li&gt;because of a cascade on at least one of the parameters (via
     * {@code @Valid})&lt;/li&gt;
     * &lt;li&gt;because of at least one cross-parameter constraint&lt;/li&gt;
     * &lt;/ul&gt;
     * Also returns {@code false} if there is no parameter.
     *
     * @return {@code true} if the executable parameters are constrained
     */
    boolean areParametersConstrained();

    /**
     * Returns {@code true} if the executable return value is constrained
     * either:
     * &lt;ul&gt;
     * &lt;li&gt;because of a constraint on the return value&lt;/li&gt;
     * &lt;li&gt;because validation is cascaded on the return value (via
     * {@code @Valid})&lt;/li&gt;
     * &lt;/ul&gt;
     * Also returns {@code false} if there is no return value.
     *
     * @return {@code true} if the executable return value is constrained
     */
    boolean isReturnValueConstrained();

    /**
     * Returns {@code false}.
     * &lt;p/&gt;
     * An executable per se does not host constraints, use
     * {@link #getParameterDescriptors()}, {@link #getCrossParameterDescriptor()}
     * and {@link #getReturnValueDescriptor()} to discover constraints.
     *
     * @return {@code false}
     */
    @Override
    boolean hasConstraints();

    /**
     * Returns an empty {@code Set}.
     * &lt;p/&gt;
     * An executable per se does not host constraints, use
     * {@link #getParameterDescriptors()}, {@link #getCrossParameterDescriptor()}
     * and {@link #getReturnValueDescriptor()} to discover constraints.
     *
     * @return An empty {@code Set}
     */
    @Override
    Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getConstraintDescriptors();

    /**
     * Returns a finder that will always return an empty {@code Set}.
     * &lt;p/&gt;
     * An executable per se does not host constraints, use
     * {@link #getParameterDescriptors()}, {@link #getCrossParameterDescriptor()}
     * and {@link #getReturnValueDescriptor()} to discover constraints.
     *
     * @return Constraint finder object.
     */
    @Override
    ConstraintFinder findConstraints();
}</programlisting>

    <para role="tck-testable"><methodname>getName()</methodname> returns the
    name of the represented method (e.g. "placeOrder") respectively the
    non-qualified name of the declaring class of the represented constructor
    (e.g. "OrderService").</para>

    <para
    role="tck-testable tck-needs-update"><methodname>getParameterDescriptors()</methodname>
    returns a list of <classname>ParameterDescriptor</classname>s representing
    the method's or constructor's parameters in order of their declaration,
    including synthetic parameters. An empty list will be returned in case the
    method or constructor has no parameters.</para>

    <para
    role="tck-testable"><methodname>getCrossParameterDescriptor()</methodname>
    returns a descriptor containing cross-parameter constraints of the method
    or constructor. If no cross-parameter constraint is present, the
    descriptor will return an empty set of constraint descriptors.</para>

    <para
    role="tck-testable"><methodname>getReturnValueDescriptor()</methodname>
    returns a descriptor for the method's or constructor's return value. A
    descriptor representing the special class <classname>void</classname>,
    without any constraint descriptors, will be returned for executables which
    have no return value.</para>

    <para
    role="tck-testable"><classname>isConstrainedOnParameters()</classname>
    returns <literal>true</literal> if any of the parameters is constrained or
    cascaded or if the represented executable has at least one cross-parameter
    constraint. Returns <literal>false</literal> if there is no
    parameter.</para>

    <para
    role="tck-testable"><classname>isConstrainedOnReturnValue()</classname>
    returns <literal>true</literal> if the return value is constrained or
    cascaded. Returns <literal>false</literal> if there is no return
    value.</para>

    <para role="tck-testable tck-needs-update">The methods
    <methodname>hasConstraints()</methodname>,
    <methodname>getConstraintDescriptors()</methodname> and
    <methodname>findConstraints()</methodname> defined on
    <classname>ElementDescriptor</classname> are redefined to clarify that
    executables do not host constraints directly and thus will always return
    <literal>false</literal> or an empty set of constraints, respectively.
    Constraint descriptors for individual parameters can be obtained from the
    corresponding <classname>ParameterDescriptor</classname> object,
    constraint descriptors for cross-parameter constraints can be obtained
    from the corresponding <classname>CrossParameterDescriptor</classname>
    object and constraint descriptors for the return value can be obtained
    from <classname>ReturnValueDescriptor</classname>.</para>

    <para>The interfaces <classname>MethodDescriptor</classname> and
    <classname>ConstructorDescriptor</classname> are derived from
    <classname>ExecutableDescriptor</classname> and allow to distinguish
    between descriptors representing methods and descriptors representing
    constructors.</para>

    <programlisting>package javax.validation.metadata;

/**
 * Describes a validated method.
 *
 * @author Gunnar Morling
 * @author Emmanuel Bernard
 * @since 1.1
 */
public interface MethodDescriptor extends ExecutableDescriptor {
}</programlisting>

    <programlisting>package javax.validation.metadata;

/**
 * Describes a validated constructor.
 *
 * @author Gunnar Morling
 * @author Emmanuel Bernard
 * @since 1.1
 */
public interface ConstructorDescriptor extends ExecutableDescriptor {
}</programlisting>

    <para><classname>MethodDescriptor</classname> objects are returned by
    <methodname>BeanDescriptor#getConstraintsForMethod(String,
    Class&lt;?&gt;...)</methodname> and
    <methodname>BeanDescriptor#getConstrainedMethods()</methodname>, while
    <classname>ConstructorDescriptor</classname> objects are returned by
    <methodname>BeanDescriptor#getConstraintsForConstructor(Class&lt;?&gt;...)</methodname>
    and
    <methodname>BeanDescriptor#getConstrainedConstructors()</methodname>.</para>

    <para role="tck-testable">None of the metadata API methods honor the XML
    configuration <literal>&lt;validated-executables/&gt;</literal> nor the
    presence of <classname>@ValidateExecutable</classname>. In other words,
    all constrained methods and constructors will be returned by the metadata
    API regardless of these settings.</para>
  </section>

  <section revisionflag="added">
    <title>ParameterDescriptor</title>

    <para>The <classname>ParameterDescriptor</classname> interface describes a
    constrained parameter of a method or constructor.</para>

    <para>This interface is returned by
    <methodname>MethodDescriptor#getParameterDescriptors()</methodname> and
    <methodname>ConstructorDescriptor#getParameterDescriptors()</methodname>.</para>

    <programlisting>package javax.validation.metadata;

/**
 * Describes a validated method or constructor parameter.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface ParameterDescriptor extends ElementDescriptor, CascadableDescriptor {

    /**
     * Returns this parameter's index within the parameter array of the method
     * or constructor holding it.
     *
     * @return This parameter's index.
     */
    int getIndex();

    /**
     * Returns this parameter's name as retrieved by the current parameter name
     * resolver.
     *
     * @return This parameter's name.
     */
    String getName();
}</programlisting>

    <para role="tck-testable"><methodname>getIndex()</methodname> returns the
    index of the represented parameter within the parameter array of the
    method or constructor holding it.</para>

    <para role="tck-testable"><methodname>getName()</methodname> returns the
    name of the represented parameter.</para>
  </section>

  <section revisionflag="added">
    <title>CrossParameterDescriptor</title>

    <para>The <classname>CrossParameterDescriptor</classname> interface
    describes a element containing all cross-parameter constraints of a method
    or constructor.</para>

    <para>This interface is returned by
    <methodname>MethodDescriptor#getCrossParameterDescriptor()</methodname>
    and
    <methodname>ConstructorDescriptor#getCrossParameterDescriptor()</methodname>.</para>

    <programlisting>package javax.validation.metadata;

/**
 * Describes an element holding cross-parameter constraints of a method or constructor
 *
 * @author Emmanuel Bernard &lt;emmanuel@hibernate.org&gt;
 * @since 1.1
 */
public interface CrossParameterDescriptor extends ElementDescriptor {

    /**
     * @return {@code Object[].class} - the type of the parameter array
     */
    @Override
    Class&lt;?&gt; getElementClass();
}</programlisting>
  </section>

  <section revisionflag="added">
    <title>ReturnValueDescriptor</title>

    <para>The <classname>ReturnValueDescriptor</classname> interface describes
    the return value of a method or constructor.</para>

    <para>This interface is returned by
    <methodname>MethodDescriptor#getReturnValueDescriptor()</methodname> and
    <methodname>ConstructorDescriptor#getReturnValueDescriptor()</methodname>.</para>

    <programlisting>package javax.validation.metadata;

/**
 * Describes a validated return value of a method or constructor.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface ReturnValueDescriptor extends ElementDescriptor, CascadableDescriptor {
}</programlisting>
  </section>

  <section id="constraintmetadata-constraintdescriptor">
    <title>ConstraintDescriptor</title>

    <para>A <classname>ConstraintDescriptor</classname> object describes a
    given constraint declaration (i.e. a constraint annotation).</para>

    <programlisting>package javax.validation.metadata;

/**
 * Describes a single constraint and its composing constraints.
 * {@code T} is the constraint's annotation type.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintDescriptor&lt;T extends Annotation&gt; {
    /**
     * Returns the annotation describing the constraint declaration.
     * If a composing constraint, attribute values are reflecting
     * the overridden attributes of the composing constraint
     *
     * @return The annotation for this constraint.
     */
    T getAnnotation();

    /**
     * The set of groups the constraint is applied on.
     * If the constraint declares no group, a set with only the {@code Default}
     * group is returned.
     *
     * @return The groups the constraint is applied on.
     */
    Set&lt;Class&lt;?&gt;&gt; getGroups();

    /**
     * The set of payload the constraint hosts.
     *
     * @return payload classes hosted on the constraint or an empty set if none.
     */
    Set&lt;Class&lt;? extends Payload&gt;&gt; getPayload();

    /**
     * List of the constraint validation implementation classes.
     *
     * @return list of the constraint validation implementation classes.
     */
    List&lt;Class&lt;? extends ConstraintValidator&lt;T, ?&gt;&gt;&gt;
    getConstraintValidatorClasses();

    /**
     * Returns a map containing the annotation attribute names as keys and the
     * annotation attribute values as value.
     * If this constraint is used as part of a composed constraint, attribute
     * values are reflecting the overridden attribute of the composing constraint.
     *
     * @return a map containing the annotation attribute names as keys
     *         and the annotation attribute values as value.
     */
    Map&lt;String, Object&gt; getAttributes();

    /**
     * Return a set of composing {@code ConstraintDescriptor}s where each
     * descriptor describes a composing constraint. {@code ConstraintDescriptor}
     * instances of composing constraints reflect overridden attribute values in
     * {@link #getAttributes()}  and {@link #getAnnotation()}.
     *
     * @return a set of {@code ConstraintDescriptor} objects or an empty set
     *         in case there are no composing constraints.
     */
    Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getComposingConstraints();

    /**
     * @return true if the constraint is annotated with {@code @ReportAsSingleViolation}
     */
    boolean isReportAsSingleViolation();
}</programlisting>

    <para><methodname>getAnnotation</methodname> returns the annotation
    instance (or an annotation instance representing the given constraint
    declaration). <phrase role="tck-testable">If
    <classname>ConstraintDescriptor</classname> represents a composing
    annotation (see <xref
    linkend="constraintsdefinitionimplementation-constraintcomposition"/>),
    the returned annotation must reflect parameter overriding.</phrase> In
    other words, the annotation parameter values are the overridden
    values.</para>

    <para><phrase role="tck-testable"><methodname>getAttributes</methodname>
    returns a map containing the annotation attribute names as a key, and the
    annotation attribute values as a value</phrase> (this API is anticipated
    to be simpler to use by tools than reflection over the annotation
    instance). <phrase role="tck-testable">If
    <classname>ConstraintDescriptor</classname> represents a composing
    annotation (see <xref
    linkend="constraintsdefinitionimplementation-constraintcomposition"/>),
    the returned <classname>Map</classname> must reflect attribute
    overriding.</phrase></para>

    <para><phrase role="tck-testable"><methodname>getGroups</methodname>
    returns the groups the constraint is supposed to be applied upon.</phrase>
    <phrase role="tck-testable">If no group is set on the constraint
    declaration, the <classname>Default</classname> group is
    returned.</phrase> <phrase role="tck-testable">The groups of a composing
    constraint are the groups of the composed constraint.</phrase></para>

    <para><phrase role="tck-testable"><literal>getPayload</literal> returns
    the payloads associated to the constraint or an empty set if
    none.</phrase> <phrase revisionflag="added" role="tck-testable">The
    payload from the main constraint annotation is inherited by the composing
    annotations.</phrase> <phrase revisionflag="added" role="tck-testable">Any
    payload definition on a composing annotation is ignored.</phrase></para>

    <para revisionflag="added"
    role="tck-testable"><methodname>isReportAsSingleViolation</methodname>
    returns true if the constraint is annotated with
    <classname>@ReportAsSingleViolation</classname>.</para>

    <para revisionflag="added"
    role="tck-testable"><methodname>getComposingConstraints</methodname>
    return a set of composing <classname>ConstraintDescriptor</classname>s
    where each descriptor describes a composing constraint.</para>

    <para><methodname>getConstraintValidatorClasses</methodname> returns the
    <classname>ConstraintValidator</classname> classes associated with the
    constraint.</para>
  </section>

  <section>
    <title>Example</title>

    <para revisionflag="added"><remark>TODO: Extend example to cover method
    constraints, too.</remark></para>

    <para>Assuming the following <classname>@NotEmpty</classname>
    definition</para>

    <programlisting>package com.acme.constraint;

@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmpty.NotEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface NotEmpty {
    String message() default "{com.acme.constraint.NotEmpty.message}"
    Class&lt;?&gt; groups() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotEmpty[] value();
    }

    class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; {
        public void initialize(NotEmpty constraintAnnotation) {}

        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}</programlisting>

    <para>and the following class definitions</para>

    <programlisting>public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {
    private String title;
    private String description;

    @Valid
    @NotNull
    private Author author;

    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    @Size(max=30)
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }

    public String getDescription() {
        return description;
    }

    public void setAuthor(String description) {
        this.description = description;
    }
}</programlisting>

    <para>The following assertions are true.</para>

    <programlisting>BeanDescriptor bookDescriptor = validator.getConstraintsForClass(Book.class);

assert ! bookDescriptor.hasConstraints();

assert bookDescriptor.isBeanConstrained();

assert bookDescriptor.getConstraintDescriptors().size() == 0 //no bean-level constraint

//more specifically "author" and "title"
assert bookDescriptor.getConstrainedProperties().size() == 2;

//not a property
assert bookDescriptor.getConstraintsForProperty("doesNotExist") == null; 

//property with no constraint
assert bookDescriptor.getConstraintsForProperty("description") == null; 

ElementDescriptor propertyDescriptor = bookDescriptor.getConstraintsForProperty("title");
assert propertyDescriptor.getConstraintDescriptors().size() == 2
assert "title".equals( propertyDescriptor.getPropertyName() );

//assuming the implementation returns the @NotEmpty constraint first
ConstraintDescriptor&lt;?&gt; constraintDescriptor = propertyDescriptor.getConstraintDescriptors()
                                                              .iterator().next();
assert constraintDescriptor.getAnnotation().getAnnotationType().equals( NotEmpty.class );
assert constraintDescriptor.getGroups().size() == 2; //FirstLevelCheck and Default
assert constraintDescriptor.getComposingConstraints().size() == 2;
assert constraintDescriptor.isReportAsSingleViolation() == true

//@NotEmpty cannot be null
boolean notNullPresence = false;
for ( ConstraintDescriptor&lt;?&gt; composingDescriptor : constraintDescriptor.getComposingConstraints() ) {
    if ( composingDescriptor.getAnnotation().getAnnotationType().equals( NotNull.class ) ) {
        notNullPresence = true;
    }
}
assert notNullPresence; 

//assuming the implementation returns the Size constraint second
constraintDescriptor = propertyDescriptor.getConstraintDescriptors().iterator().next().next();
assert constraintDescriptor.getAnnotation().getAnnotationType().equals( Size.class );
assert constraintDescriptor.getAttributes().get("max") == 30; 
assert constraintDescriptor.getGroups().size() == 1;

propertyDescriptor = bookDescriptor.getConstraintsForProperty("author");
assert propertyDescriptor.getConstraintDescriptors().size() == 1
assert propertyDescriptor.isCascaded()</programlisting>
  </section>
</chapter>
