<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../docbook-support/support/docbook-dtd/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../global.ent">
%BOOK_ENTITIES;
]>
<chapter id="constraintsdefinitionimplementation">
  <title>Constraint Definition</title>

  <para>Constraints are defined by the combination of a constraint annotation
  and a list of constraint validation implementations. The constraint
  annotation is applied on types, methods, fields or other constraint
  annotations in case of composition.</para>

  <para>Unless stated otherwise the default package name for the Bean
  Validation APIs is <classname>javax.validation</classname>.</para>

  <section id="constraintsdefinitionimplementation-constraintdefinition">
    <title>Constraint annotation</title>

    <para>A constraint on a JavaBean is expressed through one or more
    annotations. An annotation is considered a constraint definition if its
    retention policy contains <literal>RUNTIME</literal> and if the annotation
    itself is annotated with
    <literal>javax.validation.Constraint</literal>.</para>

    <programlisting>/**
 * Link between a constraint annotation and its constraint validation implementations.
 * &lt;p/&gt;
 * A given constraint annotation should be annotated by a &lt;code&gt;@Constraint&lt;/code&gt;
 * annotation which refers to its list of constraint validation implementations.
 *
 * @author Emmanuel Bernard
 * @author Gavin King
 * @author Hardy Ferentschik
 */
@Documented
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface Constraint {
    /**
     * &lt;code&gt;ConstraintValidator&lt;/code&gt; classes must reference distinct target types.
     * If two &lt;code&gt;ConstraintValidator&lt;/code&gt; refer to the same type,
     * an exception will occur.
     *
     * @return array of ConstraintValidator classes implementing the constraint
     */
    public Class&lt;? extends ConstraintValidator&lt;?, ?&gt;&gt;[] validatedBy();
}</programlisting>

    <para>Constraint annotations can target any of the following
    <classname>ElementType</classname>s:</para>

    <itemizedlist>
      <listitem>
        <para><literal>FIELD</literal> for constrained attributes</para>
      </listitem>

      <listitem>
        <para><literal>METHOD</literal> for constrained getters</para>
      </listitem>

      <listitem>
        <para><literal>TYPE</literal> for constrained beans</para>
      </listitem>

      <listitem>
        <para><literal>ANNOTATION_TYPE</literal> for constraints composing
        other constraints</para>
      </listitem>
    </itemizedlist>

    <para>While other <classname>ElementType</classname>s are not forbidden,
    the provider does not have to recognize and process constraints placed on
    such types. Built-in types do support <literal>PARAMETER</literal> and
    <literal>CONSTRUCTOR</literal> to allow Bean Validation provider specific
    extensions. It is considered good practice to follow the same approach for
    custom annotations.</para>

    <para>Since a given constraint definition applies to one or more specific
    Java types, the JavaDoc for the constraint annotation should clearly state
    which types are supported. Applying a constraint annotation to an
    incompatible type will raise an
    <classname>UnexpectedTypeException</classname>. Care should be taken on
    defining the list of <classname>ConstraintValidator</classname>s. The type
    resolution algorithm (see <xref linkend="typevalidatorresolution"/>) could
    lead to exceptions if the <classname>ConstraintValidator</classname> list
    leads to ambiguities.</para>

    <para>If a constraint definition is not valid, a
    <classname>ConstraintDefinitionException</classname> is raised either at
    validation time or when the metadata is requested. Invalid constraint
    definitions causes are multiple but include missing or illegal
    <methodname>message</methodname> or <methodname>groups</methodname>
    elements (see <xref
    linkend="constraintsdefinitionimplementation-constraintdefinition-properties"/>).</para>

    <section id="constraintsdefinitionimplementation-constraintdefinition-properties">
      <title>Constraint definition properties</title>

      <para>A constraint definition may have attributes that are specified at
      the time the constraint is applied to a JavaBean. The properties are
      mapped as annotation elements. The annotation element names
      <literal>message</literal>, <literal>groups</literal> and
      <literal>payload</literal> are considered reserved names; annotation
      elements starting with <literal>valid</literal> are not allowed; a
      constraint may use any other element name for its attributes.</para>

      <section id="constraintsdefinitionimplementation-constraintdefinition-parameters-message">
        <title>message</title>

        <para>Every constraint annotation must define a
        <literal>message</literal> element of type
        <literal>String</literal>.</para>

        <programlisting>String message() default "{com.acme.constraint.MyConstraint.message}";</programlisting>

        <para>The <methodname>message</methodname> element value is used to
        create the error message. See <xref linkend="validationapi-message"/>
        for a detailed explanation. It is recommended to default
        <literal>message</literal> values to resource bundle keys to enable
        internationalization. It is also recommended to use the following
        convention: the resource bundle key should be the fully qualified
        class name of the constraint annotation concatenated to
        <literal>.message</literal> as shown in the previous program
        listing.</para>

        <para>Built-in Bean Validation constraints follow this
        convention.</para>
      </section>

      <section id="constraintsdefinitionimplementation-constraintdefinition-groups">
        <title>groups</title>

        <para>Every constraint annotation must define a
        <literal>groups</literal> element that specifies the processing groups
        with which the constraint declaration is associated.</para>

        <programlisting>    Class&lt;?&gt;[] groups() default {};</programlisting>

        <para>The default value must be an empty array.</para>

        <para>If no group is specified when declaring the constraint on an
        element, the <literal>Default</literal> group is considered
        declared.</para>

        <para>See <xref linkend="validationapi-validatorapi-groups"/> for more
        information.</para>

        <para>Groups are typically used to control the order in which
        constraints are evaluated, or to perform validation of the partial
        state of a JavaBean.</para>
      </section>

      <section id="constraintsdefinitionimplementation-constraintdefinition-payload">
        <title>payload</title>

        <para>Constraint annotations must define a <literal>payload</literal>
        element that specifies the payload with which the the constraint
        declaration is associated.</para>

        <programlisting>    Class&lt;? extends Payload&gt;[] payload() default {};</programlisting>

        <para>The default value must be an empty array.</para>

        <para>Each attachable payload extends
        <classname>Payload</classname>.</para>

        <programlisting>/**
 * Payload type that can be attached to a given
 * constraint declaration.
 * Payloads are typically used to carry on metadata information
 * consumed by a validation client.
 *
 * Use of payloads is not considered portable.
 *
 * @author Emmanuel Bernard
 * @author Gerhard Petracek
 */
public interface Payload {
}</programlisting>

        <para>Payloads are typically used by validation clients to associate
        some metadata information with a given constraint declaration.
        Payloads are typically non-portable. Describing payloads as interface
        extensions as opposed to a string-based approach allows an easier and
        more type-safe approach.</para>

        <para>One use case for payload shown in <xref
        linkend="example-payload"/> is to associate a severity to a
        constraint. This severity can be exploited by a presentation framework
        to adjust how a constraint failure is displayed.</para>

        <example id="example-payload">
          <title>Use of payload to associate severity to a constraint</title>

          <programlisting>package com.acme.severity;

public class Severity {
    public static class Info implements Payload {};
    public static class Error implements Payload {};
}

public class Address {
    @NotNull(message="would be nice if we had one", payload=Severity.Info.class)
    public String getZipCode() {...}

    @NotNull(message="the city is mandatory", payload=Severity.Error.class) 
    String getCity() {...}
}</programlisting>
        </example>

        <para>The <literal>payload</literal> information can be retrieved from
        error reports via the <classname>ConstraintDescriptor</classname>
        either accessed through the <classname>ConstraintViolation</classname>
        objects (see <xref linkend="validationapi-constraintviolation"/>) or
        through the metadata API (see <xref
        linkend="constraintmetadata-constraintdescriptor"/>).</para>
      </section>

      <section>
        <title>Constraint specific parameter</title>

        <para>The constraint annotation definitions may define additional
        elements to parameterize the constraint. For example, a constraint
        that validates the length of a string can use an annotation element
        named <literal>length</literal> to specify the maximum length at the
        time the constraint is declared.</para>
      </section>
    </section>

    <section>
      <title>Examples</title>

      <example id="example-definition-notnull">
        <title>Simple constraint definition</title>

        <programlisting>package com.acme.constraint;

/**
 * Mark a String as representing a well formed order number
 */
@Documented
@Constraint(validatedBy = OrderNumberValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface OrderNumber {
    String message() default "{com.acme.constraint.OrderNumber.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</programlisting>
      </example>

      <para><xref linkend="example-definition-notnull"/> marks a String as a
      well-formed order number. The constraint Validator is implemented by
      <classname>OrderNumberValidator</classname>.</para>

      <example id="example-definition-length">
        <title>Constraint definition with default parameter</title>

        <programlisting>package com.acme.constraint;

/**
 * A frequency in Hz as audible to human ear.
 * Adjustable to the age of the person.
 * Accept Numbers.
 */
@Documented
@Constraint(validatedBy = AudibleValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Audible {
    Age age() default Age.YOUNG;
    String message() default "{com.acme.constraint.Audible.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    public enum Age {
        YOUNG,
        WONDERING
        OLD
    }
}</programlisting>
      </example>

      <para><xref linkend="example-definition-length"/> ensures that a given
      frequency is within the scope of human ears. The constraint definition
      includes an optional parameter that may be specified when the constraint
      is applied.</para>

      <example id="example-definition-mandatory">
        <title>Constraint definition with mandatory parameter</title>

        <programlisting>package com.acme.constraint;

/**
 * Defines the list of values accepted
 * Accepts int or Integer objects
 */
@Documented
@Constraint(validatedBy = DiscreteListOfIntegerValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Acceptable {
    int[] value();
    String message() default "{com.acme.constraint.Acceptable.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</programlisting>
      </example>

      <para><xref linkend="example-definition-mandatory"/> defines a list of
      acceptable values expressed as an array: the
      <methodname>value</methodname> property must be specified when the
      constraint is applied.</para>
    </section>
  </section>

  <section id="constraintsdefinitionimplementation-multipleconstraints">
    <title>Applying multiple constraints of the same type</title>

    <para>It is often useful to declare the same constraint more than once to
    the same target, with different properties. A common example is the
    <literal>@Pattern</literal> constraint, which validates that its target
    matches a specified regular expression. Other constraints have this
    requirement as well. The same constraint type can belong to different
    groups and have specific error messages depending on the targeted
    group.</para>

    <para>To support this requirement, the bean validation provider treats
    regular annotations (annotations not annotated by
    <classname>@Constraint</classname>) whose <literal>value</literal> element
    has a return type of an array of constraint annotations in a special way.
    Each element in the <literal>value</literal> array are processed by the
    Bean Validation implementation as regular constraint annotations. This
    means that each constraint specified in the <literal>value</literal>
    element is applied to the target. The annotation must have retention
    <literal>RUNTIME</literal> and can be applied on a type, field, property
    or another annotation. It is recommended to use the same set of targets as
    the initial constraint.</para>

    <para>Note to constraint designers: each constraint annotation should be
    coupled with its corresponding multi-valued annotation. The specification
    recommends, though does not mandate, the definition of an inner annotation
    named <classname>List</classname>.</para>

    <example>
      <title>Multi-valued constraint definition</title>

      <programlisting>/**
 * Validate a zipcode for a given country 
 * The only supported type is String
 */
@Documented
@Constraint(validatedBy = ZipCodeValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface ZipCode {

    String countryCode();

    String message() default "{com.acme.constraint.ZipCode.message}";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Defines several @ZipCode annotations on the same element
     * @see (@link ZipCode}
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        ZipCode[] value();
    }    
}</programlisting>
    </example>

    <example>
      <title>Multi-valued constraint declaration</title>

      <programlisting>public class Address {
    @ZipCode.List( {
            @ZipCode(countryCode="fr", groups=Default.class
                     message = "zip code is not valid"),
            @ZipCode(countryCode="fr", groups=SuperUser.class
                     message = "zip code invalid. Requires overriding before saving.")
            } )
    private String zipcode;
}</programlisting>
    </example>

    <para>In this example, both constraints apply to the
    <methodname>zipcode</methodname> field but with different groups and with
    different error messages.</para>

    <para>Using two different multi-constraint annotations for the same
    underlying constraint type on the same target (i.e. class or property) is
    not considered portable and is discouraged.</para>
  </section>

  <section id="constraintsdefinitionimplementation-constraintcomposition">
    <title>Constraint composition</title>

    <para>This specification allows you to compose constraints to create
    higher level constraints.</para>

    <para>Constraint composition is useful in several ways:</para>

    <itemizedlist>
      <listitem>
        <para>Avoid duplication and facilitate reuse of more primitive
        constraints.</para>
      </listitem>

      <listitem>
        <para>Expose primitive constraints as part of a composed constraint in
        the metadata API and enhance tool awareness.</para>
      </listitem>
    </itemizedlist>

    <para>Composition is done by annotating a constraint annotation with the
    composing constraint annotations.</para>

    <example>
      <title>Composition is done by annotating the composed constraint</title>

      <programlisting>@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD, CONSTRUCTOR, PARAMETER})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>
    </example>

    <para>Annotating an element with <classname>@FrenchZipcode</classname>
    (the composed annotation) is equivalent to annotating it with
    <classname>@Pattern(regexp="[0-9]*")</classname>, <classname>@Size(min=5,
    max=5)</classname> (the composing annotations) and
    <classname>@FrenchZipcode</classname>. More formally, each constraint
    annotation hosted on a constraint annotation is applied to the target
    element and this is done recursively. Note that the main annotation and
    its constraint validation implementation is also applied. By default, each
    failing constraint generates an error report. Groups from the main
    constraint annotation are inherited by the composing annotations. Any
    <methodname>groups</methodname> definition on a composing annotation is
    ignored. Likewise, payload from the main constraint annotation is
    inherited by the composing annotations. Any
    <methodname>payload</methodname> definition on a composing annotation is
    ignored.</para>

    <para>The property type upon which composed constraint is placed must be
    compatible with all constraints (composing and composed). A constraint
    designer should ensure that such a type exists and list in the JavaDoc all
    the compatible types.</para>

    <para>It is possible to ensure that composing annotations do not raise
    individual error reports. In this scenario, if one or more composing
    annotations are invalid, the main constraint is automatically considered
    invalid and the corresponding error report is generated. To mark a
    constraint as raising a single constraint error report if either the
    composed or one of the composing constraints fail, use the
    <classname>@ReportAsSingleViolation</classname> annotation.</para>

    <example>
      <title>If any of the composing constraints fail, the error report
      corresponding to @FrenchZipcode is raised and none other.</title>

      <programlisting>@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@ReportAsSingleViolation
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>
    </example>

    <para>The definition of <classname>@ReportAsSingleViolation</classname> is
    as follows.</para>

    <programlisting revisionflag="changed">/**
 * A constraint annotation hosting this annotation will return the
 * composed annotation error report if any of the composing annotations fail.
 * The error reports of each individual composing constraint are ignored.
 *
 * &lt;p&gt;
 * Note: Evaluation of composed constraints stops on the first validation
 * error in case the composing constraint is annotated with
 * {@code @ReportAsSingleViolation}.
 * &lt;/p&gt;
 *
 * @author Emmanuel Bernard
 */
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface ReportAsSingleViolation {
}</programlisting>

    <para revisionflag="changed">More specifically, if a composed constraint
    is marked as <classname>@ReportAsSingleViolation</classname>, the
    evaluation of the composing constraints stops at the first failing
    constraint and the error report corresponding to the composed constraint
    is generated and returned.</para>

    <para>Composing annotations can define the value of
    <literal>message</literal> and custom attributes (excluding
    <methodname>groups</methodname> and <methodname>payload</methodname>) but
    these are fixed in the composed constraint definition.</para>

    <example>
      <title>Composing annotations can use attributes. They are fixed for a
      given main annotation. All @FrenchZipcode constraints have a @Size
      restricted to 5.</title>

      <programlisting>@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>
    </example>

    <para>It is possible to override attributes and messages defined on a
    composing annotation. An attribute from the main annotation is used to
    override one or more attributes of the composing annotations. Such an
    attribute is annotated with the <classname>@OverridesAttribute</classname>
    annotation or its multivalued equivalent
    <classname>@OverridesAttribute.List</classname>.</para>

    <example id="example-composing-overridden">
      <title>Attributes from composing annotations can be overridden by
      attributes from the composed annotation.</title>

      <programlisting>@Pattern(regexp="[0-9]*")
@Size
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @OverridesAttribute.List( {
        @OverridesAttribute(constraint=Size.class, name="min"),
        @OverridesAttribute(constraint=Size.class, name="max") } )
    int size() default 5;

    @OverridesAttribute(constraint=Size.class, name="message")
    String sizeMessage() default "{com.acme.constraint.FrenchZipcode.zipcode.size}";

    @OverridesAttribute(constraint=Pattern.class, name="message")
    String numberMessage() default "{com.acme.constraint.FrenchZipcode.number.size}";

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>
    </example>

    <para>The value of the composed constraint attribute annotated with
    <classname>@OverridesAttribute</classname>
    (<methodname>@FrenchZipcode.sizeMessage</methodname>) is applied to the
    composing constraint attribute named after
    <methodname>OverridesAttribute.name</methodname> and hosted on the
    composing constraint of type
    <methodname>OverridesAttribute.constraint</methodname>
    (<methodname>@Size.message</methodname>). Similarly,
    <classname>@FrenchZipcode.numberMessage</classname> value is mapped to
    <classname>@Pattern.message</classname>.</para>

    <para>If left undefined, the default value for
    <methodname>@OverridesAttribute.name</methodname> is the name of the
    composed constraint attribute hosting the
    <classname>@OverridesAttribute</classname> annotation.</para>

    <para>The types of the overridden and overriding attributes must be
    identical.</para>

    <note>
      <para>A composing constraint can itself be a composed constraint. In
      this case, attribute values are overridden recursively according to the
      described rules. Note however, that a forwarding rule (as defined by
      <classname>@OverridesAttribute</classname>) is only applied to the
      direct composing constraints.</para>
    </note>

    <para>Using <xref linkend="example-composing-overridden"/>,</para>

    <programlisting>@FrenchZipcode(size=9, sizeMessage="Zipcode should be of size {max}")</programlisting>

    <para>is equivalent to</para>

    <programlisting>@FrenchZipcode</programlisting>

    <para>if <classname>@FrenchZipcode</classname> is defined as</para>

    <programlisting>@Pattern(regexp="[0-9]*")
@Size(min=9, max=9, message="Zipcode should be of size {max}")
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>

    <para>If a constraint is used more than once as a composing constraint,
    the multi value constraints model as described in <xref
    linkend="constraintsdefinitionimplementation-multipleconstraints"/> is
    used. To select a specific composing constraint,
    <methodname>OverridesAttribute.constraintIndex</methodname> is used. It
    represents the constraint index in the <methodname>value</methodname>
    array. If <literal>index</literal> is undefined, the single constraint
    declaration is targeted.</para>

    <example>
      <title>Use of constraintIndex in @OverridesAttribute</title>

      <programlisting>@Pattern.List( {
    @Pattern(regexp="[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}"), //email
    @Pattern(regexp=".*?emmanuel.*?") //emmanuel
} )
@Constraint(validatedBy={})
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface EmmanuelsEmail {
    String message() default "Not emmanuel's email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=0)
    String emailMessage() default "Not an email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=1)
    String emmanuelMessage() default "Not Emmanuel";

    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        EmmanuelsEmail[] value();
    }
}</programlisting>
    </example>

    <para><classname>@OverridesAttribute</classname> definition is as
    follows:</para>

    <programlisting>/**
 * Mark an attribute as overriding the attribute of a composing constraint.
 * Both attributes must share the same type.
 *
 * @author Emmanuel Bernard
 */
@Retention(RUNTIME)
@Target({ METHOD })
public @interface OverridesAttribute {
    /**
     * @return Constraint type the attribute is overriding
     */
    Class&lt;? extends Annotation&gt; constraint();

    /**
     * Name of the Constraint attribute overridden.
     * Defaults to the name of the attribute hosting &lt;code&gt;@OverridesAttribute&lt;/code&gt;.
     *
     * @return name of constraint attribute overridden.
     */
    String name();

    /**
     * The index of the targeted constraint declaration when using
     * multiple constraints of the same type.
     * The index represents the index of the constraint in the value() array.
     *
     * By default, no index is defined and the single constraint declaration
     * is targeted
     *
     * @return constraint declaration index if multivalued annotation is used
     */
    int constraintIndex() default -1;

    /**
     * Defines several @OverridesAttribute annotations on the same element
     * @see javax.validation.OverridesAttribute
     */
    @Documented
    @Target({ METHOD })
    @Retention(RUNTIME)
    public @interface List {
        OverridesAttribute[] value();
    }
}</programlisting>

    <para>The following elements uniquely identify an overridden constraint
    attribute:</para>

    <itemizedlist>
      <listitem>
        <para><methodname>OverridesAttribute.constraint</methodname></para>
      </listitem>

      <listitem>
        <para><methodname>OverridesAttribute.name</methodname></para>
      </listitem>

      <listitem>
        <para><methodname>OverridesAttribute.constraintIndex</methodname></para>
      </listitem>
    </itemizedlist>

    <para>If the composition is invalid (infinitely recursive composition,
    wrong attribute overriding, a single attribute mapped to more than one
    source attribute etc), a
    <classname>ConstraintDefinitionException</classname> is raised either at
    validation time or when the metadata is requested.</para>

    <para>Constraint designers are encouraged to make use of composition
    (recursively or not) based on the built-in constraints defined by the
    specification. The composing constraints are exposed through the Bean
    Validation metadata API (<xref
    linkend="constraintmetadata-constraintdescriptor"/>). This metadata is
    particularly useful for third-party metadata consumers like persistence
    frameworks generating database schemas (such as Java Persistence) or
    presentation frameworks.</para>
  </section>

  <section id="constraintsdefinitionimplementation-validationimplementation">
    <title>Constraint validation implementation</title>

    <para>A constraint validation implementation performs the validation of a
    given constraint annotation for a given type. The implementation classes
    are specified by the <literal>validatedBy</literal> element of the
    <classname>@Constraint</classname> annotation that decorates the
    constraint definition. The constraint validation implementation implements
    the <classname>ConstraintValidator</classname> interface.</para>

    <programlisting>/**
 * Defines the logic to validate a given constraint A
 * for a given object type T.
 * Implementations must comply to the following restriction:
 * &lt;ul&gt;
 * &lt;li&gt;T must resolve to a non parameterized type&lt;/li&gt;
 * &lt;li&gt;or generic parameters of T must be unbounded
 * wildcard types&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidator&lt;A extends Annotation, T&gt; {
    /**
     * Initialize the validator in preparation for isValid calls.
     * The constraint annotation for a given constraint declaration
     * is passed.
     * &lt;p/&gt;
     * This method is guaranteed to be called before any use of this instance for
     * validation.
     *
     * @param constraintAnnotation annotation instance for a given constraint declaration
     */
    void initialize(A constraintAnnotation);

    /**
     * Implement the validation logic.
     * The state of &lt;code&gt;value&lt;/code&gt; must not be altered.
     *
     * This method can be accessed concurrently, thread-safety must be ensured
     * by the implementation.
     *
     * @param value object to validate
     * @param context context in which the constraint is evaluated
     *
     * @return false if &lt;code&gt;value&lt;/code&gt; does not pass the constraint
     */
    boolean isValid(T value, ConstraintValidatorContext context);
}</programlisting>

    <para>Some restrictions apply on the generic type <classname>T</classname>
    (used in the <methodname>isValid</methodname> method).
    <classname>T</classname> must</para>

    <itemizedlist>
      <listitem>
        <para>resolve to a non parameterized type (i.e. because the type is
        not using generics or because the raw type is used instead of the
        generic version)</para>
      </listitem>

      <listitem>
        <para>or generic parameters of <classname>T</classname> must be
        unbounded wildcard types (i.e. <literal>&lt;?&gt;</literal>)</para>
      </listitem>
    </itemizedlist>

    <para><xref
    linkend="example-constraintsdefinitionimplementation-validationimplementation-validdef"/>
    shows some examples of valid definitions.</para>

    <example id="example-constraintsdefinitionimplementation-validationimplementation-validdef">
      <title>Valid ConstraintValidator definitions</title>

      <programlisting>//String is not making use of generics
public class SizeValidatorForString implements&lt;Size, String&gt; {...}

//Collection uses generics but the raw type is used
public class SizeValidatorForCollection implements&lt;Size, Collection&gt; {...}

//Collection uses generics and unbounded windcard type
public class SizeValidatorForCollection implements&lt;Size, Collection&lt;?&gt;&gt; {...}</programlisting>
    </example>

    <para>And some invalid definitions in <xref
    linkend="example-constraintsdefinitionimplementation-validationimplementation-invaliddef"/>.</para>

    <example id="example-constraintsdefinitionimplementation-validationimplementation-invaliddef">
      <title>Invalid ConstraintValidator definitions</title>

      <programlisting>//parameterized type
public class SizeValidatorForString implements&lt;Size, Collection&lt;String&gt;&gt; {...}

//parameterized type using bounded wildcard
public class SizeValidatorForCollection implements&lt;Size, Collection&lt;? extends Address&gt;&gt; {...}</programlisting>
    </example>

    <note>
      <para>This restriction is not a theoretical limitation and a future
      version of the specification will likely allow it.</para>
    </note>

    <para revisionflag="changed">The life cycle of a constraint validation
    implementation instance is undefined. Bean Validation providers are
    allowed to cache <classname>ConstraintValidator</classname> instances
    retrieved from the
    <classname>ConstraintValidatorFactory</classname>.</para>

    <!--EBE should we make explicit that instances cannot be shared if the annotations attributes are not the same?-->

    <para>The <methodname>initialize</methodname> method is called by the Bean
    validation provider prior to any use of the constraint
    implementation.</para>

    <para>The <methodname>isValid</methodname> method is evaluated by the Bean
    Validation provider each time a given value is validated. It returns
    <literal>false</literal> if the value is not valid,
    <literal>true</literal> otherwise. <literal>isValid</literal>
    implementations must be thread-safe.</para>

    <para>If the property is of an unanticipated type, an
    <literal>UnexpectedTypeException</literal> is raised.
    <classname>ConstraintValidator</classname> implementations raise this
    exception themselves if they receive an unsupported type. However,
    constraint designers are encouraged to make use of specialized
    <classname>ConstraintValidator</classname> implementations and delegate
    the type resolution to the Bean Validation provider (see the type matching
    algorithm described in <xref linkend="typevalidatorresolution"/>).</para>

    <para>If an exception occurs either in the
    <classname>initialize</classname> or <classname>isValid</classname>
    method, the runtime exception is wrapped into a
    <classname>ValidationException</classname> by the Bean Validation
    engine.</para>

    <para>The constraint validation implementation is not allowed to change
    the state of the value passed to <methodname>isValid</methodname>.</para>

    <note>
      <para>While not mandatory, it is considered a good practice to split the
      core constraint validation from the not null constraint validation (for
      example, an <classname>@Email</classname> constraint will return true on
      a null object, i.e. will not take care of the
      <classname>@NotNull</classname> validation)</para>

      <para><code>null</code> can have multiple meanings but is commonly used
      to express that a value does not make sense, is not available or is
      simply unknown. Those constraints on the value are orthogonal in most
      cases to other constraints. For example a String, if present, must be an
      email but can be null. Separating both concerns is a good
      practice.</para>
    </note>

    <para>The <classname>ConstraintValidatorContext</classname> object passed
    to the <methodname>isValid</methodname> method carries information and
    operations available in the context the constraint is validated to.</para>

    <programlisting>/**
 * Provide contextual data and operation when applying a given constraint validator.
 *
 * At least one &lt;code&gt;ConstraintViolation&lt;/code&gt; must be defined (either the default one,
 * of if the default &lt;code&gt;ConstraintViolation&lt;/code&gt; is disabled, a custom one).
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintValidatorContext {
    /**
     * Disable the default &lt;code&gt;ConstraintViolation&lt;/code&gt; object generation (which
     * is using the message template declared on the constraint).
     * Useful to set a different violation message or generate a &lt;code&gt;ConstraintViolation&lt;/Code&gt;
     * based on a different property.
     */
    void disableDefaultConstraintViolation();

    /**
     * @return the current uninterpolated default message.
     */
    String getDefaultConstraintMessageTemplate();

    /**
     * Return an constraint violation builder building an violation report
     * allowing to optionally associate it to a sub path.
     * The violation message will be interpolated.
     * &lt;p/&gt;
     * To create the &lt;code&gt;ConstraintViolation&lt;/code&gt;, one must call either one of
     * the #addConstraintViolation() methods available in one of the
     * interfaces of the fluent API.
     * If another method is called after #addConstraintViolation() on
     * &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; or any of its associated nested interfaces
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; is raised.
     * &lt;p/&gt;
     * If &lt;code&gt;isValid&lt;code&gt; returns &lt;code&gt;false&lt;/code&gt;, a &lt;code&gt;ConstraintViolation&lt;/code&gt;
     * object will be built per ConstraintViolation report including the default one (unless
     * {@link #disableDefaultConstraintViolation()} has been called).
     * &lt;p/&gt;
     * &lt;code&gt;ConstraintViolation&lt;/code&gt; objects generated from such a call
     * contain the same contextual information (root bean, path and so on) unless
     * the path has been overriden.
     * &lt;p/&gt;
     * To create a different &lt;code&gt;ConstraintViolation&lt;/code&gt;, a new constraint violation builder
     * has to be retrieved from &lt;code&gt;ConstraintValidatorContext&lt;/code&gt;
     *
     * Here are a few usage examples:
     * &lt;pre&gt;
     * {@code
     * // create new violation report with the default path the constraint is located on
     * context.buildConstraintViolationWithTemplate( "way too long" )
     *             .addConstraintViolation();
     *
     * // create new violation report in the "street" subnode of the default path
     * //the constraint is located on
     * context.buildConstraintViolationWithTemplate( "way too long" )
     *              .addNode( "street" )
     *              .addConstraintViolation();
     *
     * //create new violation report in the "addresses["home"].country.name" subnode
     * //of the default path the constraint is located on
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *              .addNode( "addresses" )
     *              .addNode( "country" )
     *                  .inIterable().atKey( "home" )
     *              .addNode( "name" )
     *              .addConstraintViolation();
     * }
     * &lt;/pre&gt;
     *
     * @param messageTemplate new uninterpolated constraint message.
     * @return Returns an constraint violation builder
     */
    ConstraintViolationBuilder buildConstraintViolationWithTemplate(String messageTemplate);

    /**
     * &lt;code&gt;ConstraintViolation&lt;/code&gt; builder allowing to optionally associate
     * the violation report to a sub path.
     *
     * To create the &lt;code&gt;ConstraintViolation&lt;/code&gt;, one must call either one of
     * the #addConstraintViolation() methods available in one of the
     * interfaces of the fluent API.
     * If another method is called after #addConstraintViolation() on
     * &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; or any of its associated objects
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; is raised.
     * 
     */
    interface ConstraintViolationBuilder {
        /**
         * Add a node to the path the &lt;code&gt;ConstraintViolation&lt;/code&gt; will be associated to.
         *
         * &lt;code&gt;name&lt;/code&gt; describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node &lt;code&gt;name&lt;/code&gt;
         */
        NodeBuilderDefinedContext addNode(String name);

        /**
         * Add the new &lt;code&gt;ConstraintViolation&lt;/code&gt; to be generated if the
         * constraint validator marks the value as invalid.
         * Methods of this &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; instance and its nested
         * objects return &lt;code&gt;IllegalStateException&lt;/code&gt; from now on.
         *
         * @return the &lt;code&gt;ConstraintValidatorContext&lt;/code&gt; instance the
         *           &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; comes from
         */
        ConstraintValidatorContext addConstraintViolation();

        /**
         * Represent a node whose context is known
         * (ie index, key and isInIterable)
         */
        interface NodeBuilderDefinedContext {

            /**
             * Add a node to the path the &lt;code&gt;ConstraintViolation&lt;/code&gt; will be associated to.
             *
             * &lt;code&gt;name&lt;/code&gt; describes a single property. In particular,
             * dot (.) are not allowed.
             *
             * @param name property &lt;code&gt;name&lt;/code&gt;
             * @return a builder representing this node
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Add the new &lt;code&gt;ConstraintViolation&lt;/code&gt; to be generated if the
             * constraint validator marks the value as invalid.
             * Methods of the &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; instance this object
             * comes from and the constraint violation builder nested
             * objects return &lt;code&gt;IllegalStateException&lt;/code&gt; after this call.
             *
             * @return &lt;code&gt;ConstraintValidatorContext&lt;/code&gt; instance the
             *           &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represent a node whose context is
         * configurable (ie index, key and isInIterable)
         */
        interface NodeBuilderCustomizableContext {

            /**
             * Mark the node as being in an &lt;code&gt;Iterable&lt;/code&gt; or a &lt;code&gt;Map&lt;/code&gt;
             * 
             * @return a builder representing iterable details
             */
            NodeContextBuilder inIterable();

            /**
             * Add a node to the path the &lt;code&gt;ConstraintViolation&lt;/code&gt; will be associated to.
             *
             * &lt;code&gt;name&lt;/code&gt; describes a single property. In particular,
             * dot (.) are not allowed.
             *
             * @param name property &lt;code&gt;name&lt;/code&gt;
             * @return a builder representing this node
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Add the new &lt;code&gt;ConstraintViolation&lt;/code&gt; to be generated if the
             * constraint validator mark the value as invalid.
             * Methods of the &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; instance this object
             * comes from and the constraint violation builder nested
             * objects return &lt;code&gt;IllegalStateException&lt;/code&gt; after this call.
             *
             * @return &lt;code&gt;ConstraintValidatorContext&lt;/code&gt; instance the
             *           &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represent refinement choices for a node which is
         * in an &lt;code&gt;Iterator&lt;/code&gt; or &lt;code&gt;Map&lt;/code&gt;.
         * If the iterator is an indexed collection or a map,
         * the index or the key should be set.
         */
        interface NodeContextBuilder {
            
            /**
             * Define the key the object is into the &lt;code&gt;Map&lt;/code&gt;
             *
             * @param key map key
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atKey(Object key);

            /**
             * Define the index the object is into the &lt;code&gt;List&lt;/code&gt; or array
             *
             * @param index index
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Add a node to the path the &lt;code&gt;ConstraintViolation&lt;/code&gt; will be associated to.
             *
             * &lt;code&gt;name&lt;/code&gt; describes a single property. In particular,
             * dot (.) are not allowed.
             *
             * @param name property &lt;code&gt;name&lt;/code&gt;
             * @return a builder representing this node
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Add the new &lt;code&gt;ConstraintViolation&lt;/code&gt; to be generated if the
             * constraint validator mark the value as invalid.
             * Methods of the &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; instance this object
             * comes from and the constraint violation builder nested
             * objects return &lt;code&gt;IllegalStateException&lt;/code&gt; after this call.
             *
             * @return &lt;code&gt;ConstraintValidatorContext&lt;/code&gt; instance the
             *           &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }
    }
}</programlisting>

    <para revisionflag="changed">The
    <classname>ConstraintValidatorContext</classname> interface allows
    redefinition of the default constraint message generated when a constraint
    is not valid. By default, each invalid constraint leads to the generation
    of one error object represented by a
    <classname>ConstraintViolation</classname> object. This object is built
    from the default constraint message template as defined by the constraint
    declaration and the context in which the constraint declaration is placed
    (bean, property, attribute, method or constructor parameter, method or
    constructor return value).</para>

    <para>The <classname>ConstraintValidatorContext</classname> methods let
    the constraint implementation disable the default
    <classname>ConstraintViolation</classname> generation and create one or
    more custom ones. The non-interpolated message passed as a parameter is
    used to build the <classname>ConstraintViolation</classname> message (the
    message interpolation operation is applied to it).</para>

    <para revisionflag="changed">By default, the <classname>Path</classname>
    exposed on the <classname>ConstraintViolation</classname> represents the
    path to the bean, property, parameter or return value hosting the
    constraint (see <xref linkend="validationapi-constraintviolation"/> for
    more information). You can point it to a subpath of this default path by
    using the constraint violation builder fluent API.</para>

    <para><xref
    linkend="example-constraintsdefinitionimplementation-validationimplementation-errorbuilder"/>
    shows a few examples.</para>

    <example id="example-constraintsdefinitionimplementation-validationimplementation-errorbuilder">
      <title>Using the fluent API to build custom constraint
      violations</title>

      <programlisting>//default path
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addConstraintViolation();

//default path + "street"
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addNode( "street" )
            .addConstraintViolation();

//default path + "addresses["home"].country.name"
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addNode( "addresses" )
            .addNode( "country" )
                .inIterable().atKey( "home" )
            .addNode( "name" )
            .addConstraintViolation();</programlisting>
    </example>

    <para>If <methodname>disableDefaultConstraintViolation</methodname> is
    called, no custom error is added (using the error builder) and if the
    constraint is not valid, a <classname>ValidationException</classname> is
    raised.</para>

    <section id="constraintsdefinitionimplementation-validationimplementation-example">
      <title>Example</title>

      <example>
        <title>ConstraintValidator implementation</title>

        <programlisting>/**
 * Check that a text is within the authorized syntax
 */
public class SyntaxValidator implements ConstraintValidator&lt;Syntax, String&gt; {
    private Set&lt;Format&gt; allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;

        return allowedFormats.size() == 0 
            || (! Collections.disjoint( guessFormat(value), allowedFormats ) );
    }

    Set&lt;Format&gt; guessFormats(String text) { ... }
}</programlisting>
      </example>

      <para>This <classname>ConstraintValidator</classname> checks that a text
      is within the accepted syntax. It also demonstrates an interesting best
      practice: return <literal>true</literal> on a null parameter</para>

      <para>The next example shows how to use
      <classname>ConstraintValidatorContext</classname>.</para>

      <example>
        <title>Use of ConstraintValidatorContext</title>

        <programlisting>/**
 * Check that a text is within the authorized syntax
 * Error messages are using either key:
 *  - com.acme.constraint.Syntax.unknown if no particular syntax is detected
 *  - com.acme.constraint.Syntax.unauthorized if the syntax is not allowed
 */
public class FineGrainedSyntaxValidator implements ConstraintValidator&lt;Syntax, String&gt; {
    private Set&lt;Format&gt; allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;
        Set&lt;Format&gt; guessedFormats = guessFormats(value);

        context.disableDefaultConstraintViolation();
        if ( guessedFormats.size() == 0 ) {
            String unknown = "{com.acme.constraint.Syntax.unknown}";
            context.buildConstraintViolationWithTemplate(unknown)
                       .addConstraintViolation();
            return false;
        }
        if ( allowedFormats.size() != 0 
            &amp;&amp; Collections.disjoint( guessedFormats, allowedFormats ) ) {

            String unauthorized = "{com.acme.constraint.Syntax.unauthorized}";
            context.buildConstraintViolationWithTemplate(unauthorized)
                       .addConstraintViolation();
            return false;
        }
        return true;
    }

    Set&lt;Format&gt; guessFormats(String text) { ... }
}</programlisting>
      </example>

      <para>The default error message is disabled and replaced by a specific
      error message depending on the type of constraint violation detected. In
      this case, only one error report is returned at a given time but a
      constraint validation implementation can return several error
      reports.</para>
    </section>
  </section>

  <section id="constraintsdefinitionimplementation-constraintfactory">
    <title>The ConstraintValidatorFactory</title>

    <para>Constraint validation implementation instances are created by a
    <classname>ConstraintValidatorFactory</classname>.</para>

    <para revisionflag="added">The life cycle of
    <classname>ConstraintValidator</classname> instances is fully dependent of
    the Bean Validation provider and piloted by the
    <classname>ConstraintValidatorFactory</classname> methods. Therefore,
    <classname>ConstraintValidatorFactory</classname> implementations (such as
    dependency injection frameworks) must consider these instances as
    belonging to a dependent scope. Bean Validation Provider must release each
    instance retrieved. This is typically done when the
    <classname>ValidatorFactory</classname> is being closed.</para>

    <example revisionflag="changed">
      <title>ConstraintValidatorFactory interface</title>

      <programlisting>/**
 * Instantiate a &lt;code&gt;ConstraintValidator&lt;/code&gt; instance based off its class.
 * The &lt;code&gt;ConstraintValidatorFactory&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; responsible
 * for calling {@link ConstraintValidator#initialize(java.lang.annotation.Annotation)}.
 *
 * @author Dhanji R. Prasanna
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidatorFactory {

    /**
     * @param key The class of the constraint validator to instantiate.
     *
     * @return A new constraint validator instance of the specified class.
     */
    &lt;T extends ConstraintValidator&lt;?,?&gt;&gt; T getInstance(Class&lt;T&gt; key);
    
    /**
     * Signal ConstraintValidatorFactory that the instance is no longer
     * being used by the Bean Validation provider
     *
     * @param instance validator being released
     */
    void releaseInstance(ConstraintValidator&lt;?,?&gt; instance);
}</programlisting>
    </example>

    <para revisionflag="changed">The default
    <classname>ConstraintValidatorFactory</classname> provided by the Bean
    Validation provider implementation uses the public no-arg constructor of
    the <classname>ConstraintValidator</classname> class. A custom
    <classname>ConstraintValidatorFactory</classname> can be provided; for
    example it may benefit from dependency injection control in constraint
    implementations (see <xref
    linkend="bootstrapping-usageandcontainerexpectation"/>). Any constraint
    implementation relying on
    <classname>ConstraintValidatorFactory</classname> behaviors specific to an
    implementation (dependency injection, no no-arg constructor and so on) are
    not portable, hence great care should be given before walking that path.
    Make sure to configure the Bean Validation provider to honor any specific
    needs your <classname>ConstraintValidator</classname> has. As constraint
    designer and writer, make sure to document any specific non compliant
    requirements.</para>

    <para><classname>ConstraintValidatorFactory</classname> should not cache
    instances as the state of each instance can be altered in the
    <methodname>initialize</methodname> method.</para>

    <para>If an exception occurs in the factory while retrieving the
    <classname>ConstraintValidator</classname> instance, the runtime exception
    is wrapped in a <classname>ValidationException</classname>. If the
    instance returned by the factory is null, a
    <classname>ValidationException</classname> is raised.</para>
  </section>
</chapter>
